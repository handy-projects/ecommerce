{"version":3,"sources":["webpack:///intl-2836431f5a13e9e641e8.js","webpack:///./~/intl/index.js","webpack:///./~/intl/lib/cldr.js","webpack:///./~/intl/lib/core.js","webpack:///./~/intl/lib/exp.js"],"names":["webpackJsonp",112,"module","exports","__webpack_require__","global","m","IntlPolyfill","Intl","__applyLocaleSensitivePrototypes","call","this",221,"isDateFormatOnly","obj","i","tmKeys","length","hasOwnProperty","isTimeFormatOnly","dtKeys","createDateTimeFormat","format","unwantedDTCs","test","undefined","formatObj","pattern","replace","expDTComponents","$0","charAt","weekday","dtcLengthMap","era","year","month","day","hour","minute","second","timeZoneName","literal","indexOf","hour12","pattern12","createDateTimeFormats","formats","expandFormat","key","M","Array","match","E","join","computed","j","availableFormats","timeFormats","dateFormats","order","medium","result","timeRelatedFormats","dateRelatedFormats","push",222,"IsStructurallyValidLanguageTag","locale","src$exp$$","expBCP47Syntax","expVariantDupes","expSingletonDupes","CanonicalizeLanguageTag","parts","toLowerCase","split","max","toUpperCase","slice","arrJoin","expExtSequences","sort","RegExp","source","hop","redundantTags","tags","subtags","extLang","arrSlice","DefaultLocale","defaultLocale","IsWellFormedCurrencyCode","currency","c","String","normalized","toLatinUpperCase","expCurrencyCode","CanonicalizeLocaleList","locales","List","seen","O","toObject","len","k","Pk","kPresent","kValue","TypeError","tag","RangeError","arrIndexOf","arrPush","BestAvailableLocale","availableLocales","candidate","pos","lastIndexOf","substring","LookupMatcher","requestedLocales","availableLocale","noExtensionsLocale","expUnicodeExSeq","Record","extension","extensionIndex","BestFitMatcher","ResolveLocale","options","relevantExtensionKeys","localeData","ReferenceError","matcher","r","foundLocale","prototype","extensionSubtags","extensionSubtagsLength","supportedExtension","foundLocaleData","keyLocaleData","value","supportedExtensionAddition","keyPos","requestedValue","valuePos","optionsValue","preExtension","postExtension","LookupSupportedLocales","subset","subsetArray","BestFitSupportedLocales","SupportedLocales","localeMatcher","P","defineProperty","writable","configurable","GetOption","property","type","values","fallback","Boolean","GetNumberOption","minimum","maximum","Number","isNaN","Math","floor","NumberFormatConstructor","arguments","InitializeNumberFormat","NumberFormat","numberFormat","internal","getInternalProperties","regexpState","createRegExpRestore","secret","opt","internals","dataLocale","s","cDigits","CurrencyDigits","cd","mnid","mnfdDefault","mnfd","mxfdDefault","mxfd","mnsd","minimumSignificantDigits","mxsd","maximumSignificantDigits","g","dataLocaleData","patterns","stylePatterns","positivePattern","negativePattern","es3","GetFormatNumber","exp","input","currencyMinorUnits","F","FormatNumber","bf","fnBind","x","n","nums","data","ild","symbols","latn","negative","isFinite","nan","infinity","ToRawPrecision","ToRawFixed","numSys","digits","digit","decimal","igr","pgSize","primaryGroupSize","sgSize","secondaryGroupSize","groups","end","idx","start","group","cData","currencies","minPrecision","maxPrecision","p","e","log10Floor","abs","f","round","LN10","cut","minInteger","minFraction","maxFraction","toFixed","z","DateTimeFormatConstructor","InitializeDateTimeFormat","DateTimeFormat","dateTimeFormat","ToDateTimeOptions","tz","timeZone","prop","dateTimeComponents","bestFormat","ToDateTimeFormats","BasicFormatMatcher","BestFitFormatMatcher","hr12","hourNo0","GetFormatDateTime","Object","toString","src$cldr$$","required","defaults","opt2","create","objCreate","needDefaults","calculateScore","bestFit","diffDataTypePenalty","removalPenalty","additionPenalty","longLessPenalty","longMorePenalty","shortLessPenalty","shortMorePenalty","bestScore","Infinity","score","optionsProp","formatProp","optionsPropIndex","formatPropIndex","delta","min","Date","now","FormatDateTime","__getInternalProperties","nf","useGrouping","nf2","minimumIntegerDigits","tm","ToLocalTime","calendars","ca","pm","fv","v","dateWidths","resolveDateString","Error","date","calendar","d","[[weekday]]","[[era]]","[[year]]","[[month]]","[[day]]","[[hour]]","[[minute]]","[[second]]","[[inDST]]","addLocaleData","number","arrShift","nu","numberFormatProtoInitialised","dateTimeFormatProtoInitialised","log10","log","LOG10E","supportedLocalesOf","component","width","gregory","alts","narrow","short","long","resolved","enumerable","apply","esc","lm","lastMatch","ml","multiline","ret","reg","has","cap","str","ch","arg","realDefineProp","sentinel","__defineGetter__","name","desc","get","search","t","proto","props","arrConcat","concat","shift","unshift","Function","bind","thisObj","fn","args","a","random","art-lojban","i-ami","i-bnn","i-hak","i-klingon","i-lux","i-navajo","i-pwn","i-tao","i-tay","i-tsu","no-bok","no-nyn","sgn-BE-FR","sgn-BE-NL","sgn-CH-DE","zh-guoyu","zh-hakka","zh-min-nan","zh-xiang","sgn-BR","sgn-CO","sgn-DE","sgn-DK","sgn-ES","sgn-FR","sgn-GB","sgn-GR","sgn-IE","sgn-IT","sgn-JP","sgn-MX","sgn-NI","sgn-NL","sgn-NO","sgn-PT","sgn-SE","sgn-US","sgn-ZA","zh-cmn","zh-cmn-Hans","zh-cmn-Hant","zh-gan","zh-wuu","zh-yue","BU","DD","FX","TP","YD","ZR","heploc","in","iw","ji","jw","mo","ayx","bjd","ccq","cjr","cka","cmk","drh","drw","gav","hrr","ibi","kgh","lcq","mst","myt","sca","tie","tkk","tlw","tnf","ybd","yma","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","aed","aen","afb","afg","ajp","apc","apd","arb","arq","ars","ary","arz","ase","asf","asp","asq","asw","auz","avl","ayh","ayl","ayn","ayp","bbz","bfi","bfk","bjn","bog","bqn","bqy","btj","bve","bvl","bvu","bzs","cdo","cds","cjy","cmn","coa","cpx","csc","csd","cse","csf","csg","csl","csn","csq","csr","czh","czo","doq","dse","dsl","dup","ecs","esl","esn","eso","eth","fcs","fse","fsl","fss","gan","gds","gom","gse","gsg","gsm","gss","gus","hab","haf","hak","hds","hji","hks","hos","hps","hsh","hsl","hsn","icl","ils","inl","ins","ise","isg","isr","jak","jax","jcs","jhs","jls","jos","jsl","jus","kgi","knn","kvb","kvk","kvr","kxd","lbs","lce","lcf","liw","lls","lsg","lsl","lso","lsp","lst","lsy","ltg","lvs","lzh","mdl","meo","mfa","mfb","mfs","mnp","mqg","mre","msd","msi","msr","mui","mzc","mzg","mzy","nbs","ncs","nsi","nsl","nsp","nsr","nzs","okl","orn","ors","pel","pga","pks","prl","prz","psc","psd","pse","psg","psl","pso","psp","psr","pys","rms","rsi","rsl","sdl","sfb","sfs","sgg","sgx","shu","slf","sls","sqk","sqs","ssh","ssp","ssr","svk","swc","swh","swl","syy","tmw","tse","tsm","tsq","tss","tsy","tza","ugn","ugy","ukl","uks","urk","uzn","uzs","vgt","vkk","vkt","vsi","vsl","vsv","wuu","xki","xml","xmm","xms","yds","ysl","yue","zib","zlm","zmi","zsl","zsm","BHD","BYR","XOF","BIF","XAF","CLF","CLP","KMF","DJF","XPF","GNF","ISK","IQD","JPY","JOD","KRW","KWD","LYD","OMR","PYG","RWF","TND","UGX","UYI","VUV","VND","[[availableLocales]]","[[relevantExtensionKeys]]","[[localeData]]","arab","arabext","bali","beng","deva","fullwide","gujr","guru","hanidec","khmr","knda","laoo","limb","mlym","mong","mymr","orya","tamldec","telu","thai","tibt","descs","ls","__localeSensitiveProtos","toLocaleString","toLocaleDateString","toLocaleTimeString",223,"extlang","language","script","region","variant","singleton","privateuse","irregular","regular","grandfathered","langtag",397],"mappings":"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","file":"intl-2836431f5a13e9e641e8.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 112:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var m = __webpack_require__(222),\n\t    IntlPolyfill = m.default;\n\t\n\t// Expose `IntlPolyfill` as global to add locale data into runtime later on.\n\tglobal.IntlPolyfill = IntlPolyfill;\n\t\n\t// Require all locale data for `Intl`. This module will be\n\t// ignored when bundling for the browser with Browserify/Webpack.\n\t__webpack_require__(397);\n\t\n\t// hack to export the polyfill as global Intl if needed\n\tif (!global.Intl) {\n\t    global.Intl = IntlPolyfill;\n\t    IntlPolyfill.__applyLocaleSensitivePrototypes();\n\t}\n\t\n\t// providing an idiomatic api for the nodejs version of this module\n\tmodule.exports = exports = IntlPolyfill;\n\t// preserving the original api in case another module is relying on that\n\texports.default = IntlPolyfill;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n\n/***/ 221:\n/***/ function(module, exports) {\n\n\t/* jslint esnext: true */\n\t\n\t// Match these datetime components in a CLDR pattern, except those in single quotes\n\t\"use strict\";\n\texports.createDateTimeFormat = createDateTimeFormat, exports.createDateTimeFormats = createDateTimeFormats;\n\tvar expDTComponents = /(?:[Eec]{1,6}|G{1,5}|(?:[yYu]+|U{1,5})|[ML]{1,5}|d{1,2}|a|[hkHK]{1,2}|m{1,2}|s{1,2}|z{1,4})(?=([^']*'[^']*')*[^']*$)/g;\n\t\n\t// Skip over patterns with these datetime components\n\tvar unwantedDTCs = /[QxXVOvZASjgFDwWIQqH]/;\n\t\n\t// Maps the number of characters in a CLDR pattern to the specification\n\tvar dtcLengthMap = {\n\t        month:   [ 'numeric', '2-digit', 'short', 'long', 'narrow' ],\n\t        weekday: [ 'short', 'short', 'short', 'long', 'narrow' ],\n\t        era:     [ 'short', 'short', 'short', 'long', 'narrow' ]\n\t    };\n\t\n\tvar dtKeys = [\"weekday\", \"era\", \"year\", \"month\", \"day\"];\n\tvar tmKeys = [\"hour\", \"minute\", \"second\", \"timeZoneName\"];\n\t\n\tfunction isDateFormatOnly(obj) {\n\t    for (var i = 0; i < tmKeys.length; i += 1) {\n\t        if (obj.hasOwnProperty(tmKeys[i])) {\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t}\n\t\n\tfunction isTimeFormatOnly(obj) {\n\t    for (var i = 0; i < dtKeys.length; i += 1) {\n\t        if (obj.hasOwnProperty(dtKeys[i])) {\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t}\n\t\n\tfunction createDateTimeFormat(format) {\n\t    if (unwantedDTCs.test(format))\n\t        return undefined;\n\t\n\t    var formatObj = {};\n\t\n\t    // Replace the pattern string with the one required by the specification, whilst\n\t    // at the same time evaluating it for the subsets and formats\n\t    formatObj.pattern = format.replace(expDTComponents, function ($0) {\n\t        // See which symbol we're dealing with\n\t        switch ($0.charAt(0)) {\n\t            case 'E':\n\t            case 'e':\n\t            case 'c':\n\t                formatObj.weekday = dtcLengthMap.weekday[$0.length-1];\n\t                return '{weekday}';\n\t\n\t            // Not supported yet\n\t            case 'G':\n\t                formatObj.era = dtcLengthMap.era[$0.length-1];\n\t                return '{era}';\n\t\n\t            case 'y':\n\t            case 'Y':\n\t            case 'u':\n\t            case 'U':\n\t                formatObj.year = $0.length === 2 ? '2-digit' : 'numeric';\n\t                return '{year}';\n\t\n\t            case 'M':\n\t            case 'L':\n\t                formatObj.month = dtcLengthMap.month[$0.length-1];\n\t                return '{month}';\n\t\n\t            case 'd':\n\t                formatObj.day = $0.length === 2 ? '2-digit' : 'numeric';\n\t                return '{day}';\n\t\n\t            case 'a':\n\t                return '{ampm}';\n\t\n\t            case 'h':\n\t            case 'H':\n\t            case 'k':\n\t            case 'K':\n\t                formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n\t                return '{hour}';\n\t\n\t            case 'm':\n\t                formatObj.minute = $0.length === 2 ? '2-digit' : 'numeric';\n\t                return '{minute}';\n\t\n\t            case 's':\n\t                formatObj.second = $0.length === 2 ? '2-digit' : 'numeric';\n\t                return '{second}';\n\t\n\t            case 'z':\n\t                formatObj.timeZoneName = $0.length < 4 ? 'short' : 'long';\n\t                return '{timeZoneName}';\n\t        }\n\t    });\n\t\n\t    // From http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns:\n\t    //  'In patterns, two single quotes represents a literal single quote, either\n\t    //   inside or outside single quotes. Text within single quotes is not\n\t    //   interpreted in any way (except for two adjacent single quotes).'\n\t    formatObj.pattern = formatObj.pattern.replace(/'([^']*)'/g, function ($0, literal) {\n\t        return literal ? literal : \"'\";\n\t    });\n\t\n\t    if (formatObj.pattern.indexOf('{ampm}') > -1) {\n\t        formatObj.hour12 = true;\n\t        formatObj.pattern12 = formatObj.pattern;\n\t        formatObj.pattern = formatObj.pattern.replace('{ampm}', '').replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\t    }\n\t\n\t    return formatObj;\n\t}\n\t\n\tfunction createDateTimeFormats(formats) {\n\t    var availableFormats = formats.availableFormats;\n\t    var timeFormats = formats.timeFormats;\n\t    var dateFormats = formats.dateFormats;\n\t    var order = formats.medium;\n\t    var result = [];\n\t    var key, format, computed, i, j;\n\t    var timeRelatedFormats = [];\n\t    var dateRelatedFormats = [];\n\t\n\t    function expandFormat(key, pattern) {\n\t        // Expand component lengths if necessary, as allowed in the LDML spec\n\t        // Get the lengths of 'M' and 'E' substrings in the date pattern\n\t        // as arrays that can be joined to create a new substring\n\t        var M = new Array((key.match(/M/g)||[]).length + 1);\n\t        var E = new Array((key.match(/E/g)||[]).length + 1);\n\t\n\t        // note from caridy: I'm not sure we really need this, seems to be\n\t        //                   useless since it relies on the keys from CLDR\n\t        //                   instead of the actual format pattern, but I'm not sure.\n\t        if (M.length > 2)\n\t            pattern = pattern.replace(/(M|L)+/, M.join('$1'));\n\t\n\t        if (E.length > 2)\n\t            pattern = pattern.replace(/([Eec])+/, E.join('$1'));\n\t\n\t        return pattern;\n\t    }\n\t\n\t    // Map available (custom) formats into a pattern for createDateTimeFormats\n\t    for (key in availableFormats) {\n\t        if (availableFormats.hasOwnProperty(key)) {\n\t            format = expandFormat(key, availableFormats[key]);\n\t            computed = createDateTimeFormat(format);\n\t            if (computed) {\n\t                result.push(computed);\n\t                // in some cases, the format is only displaying date specific props\n\t                // or time specific props, in which case we need to also produce the\n\t                // combined formats.\n\t                if (isDateFormatOnly(computed)) {\n\t                    dateRelatedFormats.push(format);\n\t                } else if (isTimeFormatOnly(computed)) {\n\t                    timeRelatedFormats.push(format);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    // combine custom time and custom date formats when they are orthogonals to complete the\n\t    // formats supported by browsers by relying on the value of \"formats.medium\" which defines\n\t    // how to join custom formats into a single pattern.\n\t    for (i = 0; i < timeRelatedFormats.length; i += 1) {\n\t        for (j = 0; j < dateRelatedFormats.length; j += 1) {\n\t            format = order\n\t                .replace('{0}', timeRelatedFormats[i])\n\t                .replace('{1}', dateRelatedFormats[j])\n\t                .replace(/^[,\\s]+|[,\\s]+$/gi, '');\n\t            computed = createDateTimeFormat(format);\n\t            if (computed) {\n\t                result.push(computed);\n\t            }\n\t        }\n\t    }\n\t\n\t    // Map time formats into a pattern for createDateTimeFormats\n\t    for (key in timeFormats) {\n\t        if (timeFormats.hasOwnProperty(key)) {\n\t            format = expandFormat(key, timeFormats[key]);\n\t            computed = createDateTimeFormat(format);\n\t            if (computed) {\n\t                result.push(computed);\n\t            }\n\t        }\n\t    }\n\t\n\t    // Map date formats into a pattern for createDateTimeFormats\n\t    for (key in dateFormats) {\n\t        if (dateFormats.hasOwnProperty(key)) {\n\t            format = expandFormat(key, dateFormats[key]);\n\t            computed = createDateTimeFormat(format);\n\t            if (computed) {\n\t                result.push(computed);\n\t            }\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\t//# sourceMappingURL=cldr.js.map\n\n/***/ },\n\n/***/ 222:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @license Copyright 2013 Andy Earnshaw, MIT License\n\t *\n\t * Implements the ECMAScript Internationalization API in ES5-compatible environments,\n\t * following the ECMA-402 specification as closely as possible\n\t *\n\t * ECMA-402: http://ecma-international.org/ecma-402/1.0/\n\t *\n\t * CLDR format locale data should be provided using IntlPolyfill.__addLocaleData().\n\t */\n\t/*jshint esnext: true, proto:true, eqnull:true, boss:true, laxbreak:true, newcap:false, shadow:true, funcscope:true */\n\t\n\t\"use strict\";\n\tvar src$exp$$ = __webpack_require__(223), src$cldr$$ = __webpack_require__(221);\n\t\n\tvar Intl = {},\n\t\n\t    realDefineProp = (function () {\n\t        var sentinel = {};\n\t        try {\n\t            Object.defineProperty(sentinel, 'a', {});\n\t            return 'a' in sentinel;\n\t        } catch (e) {\n\t            return false;\n\t        }\n\t    })(),\n\t\n\t    // Need a workaround for getters in ES3\n\t    es3  = !realDefineProp && !Object.prototype.__defineGetter__,\n\t\n\t    // We use this a lot (and need it for proto-less objects)\n\t    hop = Object.prototype.hasOwnProperty,\n\t\n\t    // Naive defineProperty for compatibility\n\t    defineProperty = realDefineProp ? Object.defineProperty : function (obj, name, desc) {\n\t        if ('get' in desc && obj.__defineGetter__)\n\t            obj.__defineGetter__(name, desc.get);\n\t\n\t        else if (!hop.call(obj, name) || 'value' in desc)\n\t            obj[name] = desc.value;\n\t    },\n\t\n\t    // Array.prototype.indexOf, as good as we need it to be\n\t    arrIndexOf = Array.prototype.indexOf || function (search) {\n\t        /*jshint validthis:true */\n\t        var t = this;\n\t        if (!t.length)\n\t            return -1;\n\t\n\t        for (var i = arguments[1] || 0, max = t.length; i < max; i++) {\n\t            if (t[i] === search)\n\t                return i;\n\t        }\n\t\n\t        return -1;\n\t    },\n\t\n\t    // Create an object with the specified prototype (2nd arg required for Record)\n\t    objCreate = Object.create || function (proto, props) {\n\t        var obj;\n\t\n\t        function F() {}\n\t        F.prototype = proto;\n\t        obj = new F();\n\t\n\t        for (var k in props) {\n\t            if (hop.call(props, k))\n\t                defineProperty(obj, k, props[k]);\n\t        }\n\t\n\t        return obj;\n\t    },\n\t\n\t    // Snapshot some (hopefully still) native built-ins\n\t    arrSlice  = Array.prototype.slice,\n\t    arrConcat = Array.prototype.concat,\n\t    arrPush   = Array.prototype.push,\n\t    arrJoin   = Array.prototype.join,\n\t    arrShift  = Array.prototype.shift,\n\t    arrUnshift= Array.prototype.unshift,\n\t\n\t    // Naive Function.prototype.bind for compatibility\n\t    fnBind = Function.prototype.bind || function (thisObj) {\n\t        var fn = this,\n\t            args = arrSlice.call(arguments, 1);\n\t\n\t        // All our (presently) bound functions have either 1 or 0 arguments. By returning\n\t        // different function signatures, we can pass some tests in ES3 environments\n\t        if (fn.length === 1) {\n\t            return function (a) {\n\t                return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n\t            };\n\t        }\n\t        else {\n\t            return function () {\n\t                return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n\t            };\n\t        }\n\t    },\n\t\n\t    // Default locale is the first-added locale data for us\n\t    defaultLocale,\n\t\n\t    // Object housing internal properties for constructors\n\t    internals = objCreate(null),\n\t\n\t    // Keep internal properties internal\n\t    secret = Math.random(),\n\t\n\t    // An object map of date component keys, saves using a regex later\n\t    dateWidths = objCreate(null, { narrow:{}, short:{}, long:{} }),\n\t\n\t    // Each constructor prototype should be an instance of the constructor itself, but we\n\t    // can't initialise them as such until some locale data has been added, so this is how\n\t    // we keep track\n\t    numberFormatProtoInitialised = false,\n\t    dateTimeFormatProtoInitialised = false,\n\t\n\t    // Some regular expressions we're using\n\t    expCurrencyCode = /^[A-Z]{3}$/,\n\t    expUnicodeExSeq = /-u(?:-[0-9a-z]{2,8})+/gi, // See `extension` below\n\t\n\t    // IANA Subtag Registry redundant tag and subtag maps\n\t    redundantTags = {\n\t        tags: {\n\t            \"art-lojban\":   \"jbo\",       \"i-ami\":        \"ami\",       \"i-bnn\":       \"bnn\",  \"i-hak\":      \"hak\",\n\t            \"i-klingon\":    \"tlh\",       \"i-lux\":        \"lb\",        \"i-navajo\":    \"nv\",   \"i-pwn\":      \"pwn\",\n\t            \"i-tao\":        \"tao\",       \"i-tay\":        \"tay\",       \"i-tsu\":       \"tsu\",  \"no-bok\":     \"nb\",\n\t            \"no-nyn\":       \"nn\",        \"sgn-BE-FR\":    \"sfb\",       \"sgn-BE-NL\":   \"vgt\",  \"sgn-CH-DE\":  \"sgg\",\n\t            \"zh-guoyu\":     \"cmn\",       \"zh-hakka\":     \"hak\",       \"zh-min-nan\":  \"nan\",  \"zh-xiang\":   \"hsn\",\n\t            \"sgn-BR\":       \"bzs\",       \"sgn-CO\":       \"csn\",       \"sgn-DE\":      \"gsg\",  \"sgn-DK\":     \"dsl\",\n\t            \"sgn-ES\":       \"ssp\",       \"sgn-FR\":       \"fsl\",       \"sgn-GB\":      \"bfi\",  \"sgn-GR\":     \"gss\",\n\t            \"sgn-IE\":       \"isg\",       \"sgn-IT\":       \"ise\",       \"sgn-JP\":      \"jsl\",  \"sgn-MX\":     \"mfs\",\n\t            \"sgn-NI\":       \"ncs\",       \"sgn-NL\":       \"dse\",       \"sgn-NO\":      \"nsl\",  \"sgn-PT\":     \"psr\",\n\t            \"sgn-SE\":       \"swl\",       \"sgn-US\":       \"ase\",       \"sgn-ZA\":      \"sfs\",  \"zh-cmn\":     \"cmn\",\n\t            \"zh-cmn-Hans\":  \"cmn-Hans\",  \"zh-cmn-Hant\":  \"cmn-Hant\",  \"zh-gan\":      \"gan\",  \"zh-wuu\":     \"wuu\",\n\t            \"zh-yue\":       \"yue\"\n\t        },\n\t        subtags: {\n\t              BU: \"MM\",   DD: \"DE\",   FX: \"FR\",   TP: \"TL\",   YD: \"YE\",   ZR: \"CD\",  heploc: \"alalc97\",\n\t            'in': \"id\",   iw: \"he\",   ji:  \"yi\",  jw: \"jv\",   mo: \"ro\",  ayx: \"nun\", bjd: \"drl\",\n\t             ccq: \"rki\", cjr: \"mom\", cka: \"cmr\", cmk: \"xch\", drh: \"khk\", drw: \"prs\", gav: \"dev\",\n\t             hrr: \"jal\", ibi: \"opa\", kgh: \"kml\", lcq: \"ppr\", mst: \"mry\", myt: \"mry\", sca: \"hle\",\n\t             tie: \"ras\", tkk: \"twm\", tlw: \"weo\", tnf: \"prs\", ybd: \"rki\", yma: \"lrr\"\n\t        },\n\t        extLang: {\n\t            aao: [ \"aao\", \"ar\"  ], abh: [ \"abh\", \"ar\"  ], abv: [ \"abv\", \"ar\"  ], acm: [ \"acm\", \"ar\"  ],\n\t            acq: [ \"acq\", \"ar\"  ], acw: [ \"acw\", \"ar\"  ], acx: [ \"acx\", \"ar\"  ], acy: [ \"acy\", \"ar\"  ],\n\t            adf: [ \"adf\", \"ar\"  ], ads: [ \"ads\", \"sgn\" ], aeb: [ \"aeb\", \"ar\"  ], aec: [ \"aec\", \"ar\"  ],\n\t            aed: [ \"aed\", \"sgn\" ], aen: [ \"aen\", \"sgn\" ], afb: [ \"afb\", \"ar\"  ], afg: [ \"afg\", \"sgn\" ],\n\t            ajp: [ \"ajp\", \"ar\"  ], apc: [ \"apc\", \"ar\"  ], apd: [ \"apd\", \"ar\"  ], arb: [ \"arb\", \"ar\"  ],\n\t            arq: [ \"arq\", \"ar\"  ], ars: [ \"ars\", \"ar\"  ], ary: [ \"ary\", \"ar\"  ], arz: [ \"arz\", \"ar\"  ],\n\t            ase: [ \"ase\", \"sgn\" ], asf: [ \"asf\", \"sgn\" ], asp: [ \"asp\", \"sgn\" ], asq: [ \"asq\", \"sgn\" ],\n\t            asw: [ \"asw\", \"sgn\" ], auz: [ \"auz\", \"ar\"  ], avl: [ \"avl\", \"ar\"  ], ayh: [ \"ayh\", \"ar\"  ],\n\t            ayl: [ \"ayl\", \"ar\"  ], ayn: [ \"ayn\", \"ar\"  ], ayp: [ \"ayp\", \"ar\"  ], bbz: [ \"bbz\", \"ar\"  ],\n\t            bfi: [ \"bfi\", \"sgn\" ], bfk: [ \"bfk\", \"sgn\" ], bjn: [ \"bjn\", \"ms\"  ], bog: [ \"bog\", \"sgn\" ],\n\t            bqn: [ \"bqn\", \"sgn\" ], bqy: [ \"bqy\", \"sgn\" ], btj: [ \"btj\", \"ms\"  ], bve: [ \"bve\", \"ms\"  ],\n\t            bvl: [ \"bvl\", \"sgn\" ], bvu: [ \"bvu\", \"ms\"  ], bzs: [ \"bzs\", \"sgn\" ], cdo: [ \"cdo\", \"zh\"  ],\n\t            cds: [ \"cds\", \"sgn\" ], cjy: [ \"cjy\", \"zh\"  ], cmn: [ \"cmn\", \"zh\"  ], coa: [ \"coa\", \"ms\"  ],\n\t            cpx: [ \"cpx\", \"zh\"  ], csc: [ \"csc\", \"sgn\" ], csd: [ \"csd\", \"sgn\" ], cse: [ \"cse\", \"sgn\" ],\n\t            csf: [ \"csf\", \"sgn\" ], csg: [ \"csg\", \"sgn\" ], csl: [ \"csl\", \"sgn\" ], csn: [ \"csn\", \"sgn\" ],\n\t            csq: [ \"csq\", \"sgn\" ], csr: [ \"csr\", \"sgn\" ], czh: [ \"czh\", \"zh\"  ], czo: [ \"czo\", \"zh\"  ],\n\t            doq: [ \"doq\", \"sgn\" ], dse: [ \"dse\", \"sgn\" ], dsl: [ \"dsl\", \"sgn\" ], dup: [ \"dup\", \"ms\"  ],\n\t            ecs: [ \"ecs\", \"sgn\" ], esl: [ \"esl\", \"sgn\" ], esn: [ \"esn\", \"sgn\" ], eso: [ \"eso\", \"sgn\" ],\n\t            eth: [ \"eth\", \"sgn\" ], fcs: [ \"fcs\", \"sgn\" ], fse: [ \"fse\", \"sgn\" ], fsl: [ \"fsl\", \"sgn\" ],\n\t            fss: [ \"fss\", \"sgn\" ], gan: [ \"gan\", \"zh\"  ], gds: [ \"gds\", \"sgn\" ], gom: [ \"gom\", \"kok\" ],\n\t            gse: [ \"gse\", \"sgn\" ], gsg: [ \"gsg\", \"sgn\" ], gsm: [ \"gsm\", \"sgn\" ], gss: [ \"gss\", \"sgn\" ],\n\t            gus: [ \"gus\", \"sgn\" ], hab: [ \"hab\", \"sgn\" ], haf: [ \"haf\", \"sgn\" ], hak: [ \"hak\", \"zh\"  ],\n\t            hds: [ \"hds\", \"sgn\" ], hji: [ \"hji\", \"ms\"  ], hks: [ \"hks\", \"sgn\" ], hos: [ \"hos\", \"sgn\" ],\n\t            hps: [ \"hps\", \"sgn\" ], hsh: [ \"hsh\", \"sgn\" ], hsl: [ \"hsl\", \"sgn\" ], hsn: [ \"hsn\", \"zh\"  ],\n\t            icl: [ \"icl\", \"sgn\" ], ils: [ \"ils\", \"sgn\" ], inl: [ \"inl\", \"sgn\" ], ins: [ \"ins\", \"sgn\" ],\n\t            ise: [ \"ise\", \"sgn\" ], isg: [ \"isg\", \"sgn\" ], isr: [ \"isr\", \"sgn\" ], jak: [ \"jak\", \"ms\"  ],\n\t            jax: [ \"jax\", \"ms\"  ], jcs: [ \"jcs\", \"sgn\" ], jhs: [ \"jhs\", \"sgn\" ], jls: [ \"jls\", \"sgn\" ],\n\t            jos: [ \"jos\", \"sgn\" ], jsl: [ \"jsl\", \"sgn\" ], jus: [ \"jus\", \"sgn\" ], kgi: [ \"kgi\", \"sgn\" ],\n\t            knn: [ \"knn\", \"kok\" ], kvb: [ \"kvb\", \"ms\"  ], kvk: [ \"kvk\", \"sgn\" ], kvr: [ \"kvr\", \"ms\"  ],\n\t            kxd: [ \"kxd\", \"ms\"  ], lbs: [ \"lbs\", \"sgn\" ], lce: [ \"lce\", \"ms\"  ], lcf: [ \"lcf\", \"ms\"  ],\n\t            liw: [ \"liw\", \"ms\"  ], lls: [ \"lls\", \"sgn\" ], lsg: [ \"lsg\", \"sgn\" ], lsl: [ \"lsl\", \"sgn\" ],\n\t            lso: [ \"lso\", \"sgn\" ], lsp: [ \"lsp\", \"sgn\" ], lst: [ \"lst\", \"sgn\" ], lsy: [ \"lsy\", \"sgn\" ],\n\t            ltg: [ \"ltg\", \"lv\"  ], lvs: [ \"lvs\", \"lv\"  ], lzh: [ \"lzh\", \"zh\"  ], max: [ \"max\", \"ms\"  ],\n\t            mdl: [ \"mdl\", \"sgn\" ], meo: [ \"meo\", \"ms\"  ], mfa: [ \"mfa\", \"ms\"  ], mfb: [ \"mfb\", \"ms\"  ],\n\t            mfs: [ \"mfs\", \"sgn\" ], min: [ \"min\", \"ms\"  ], mnp: [ \"mnp\", \"zh\"  ], mqg: [ \"mqg\", \"ms\"  ],\n\t            mre: [ \"mre\", \"sgn\" ], msd: [ \"msd\", \"sgn\" ], msi: [ \"msi\", \"ms\"  ], msr: [ \"msr\", \"sgn\" ],\n\t            mui: [ \"mui\", \"ms\"  ], mzc: [ \"mzc\", \"sgn\" ], mzg: [ \"mzg\", \"sgn\" ], mzy: [ \"mzy\", \"sgn\" ],\n\t            nan: [ \"nan\", \"zh\"  ], nbs: [ \"nbs\", \"sgn\" ], ncs: [ \"ncs\", \"sgn\" ], nsi: [ \"nsi\", \"sgn\" ],\n\t            nsl: [ \"nsl\", \"sgn\" ], nsp: [ \"nsp\", \"sgn\" ], nsr: [ \"nsr\", \"sgn\" ], nzs: [ \"nzs\", \"sgn\" ],\n\t            okl: [ \"okl\", \"sgn\" ], orn: [ \"orn\", \"ms\"  ], ors: [ \"ors\", \"ms\"  ], pel: [ \"pel\", \"ms\"  ],\n\t            pga: [ \"pga\", \"ar\"  ], pks: [ \"pks\", \"sgn\" ], prl: [ \"prl\", \"sgn\" ], prz: [ \"prz\", \"sgn\" ],\n\t            psc: [ \"psc\", \"sgn\" ], psd: [ \"psd\", \"sgn\" ], pse: [ \"pse\", \"ms\"  ], psg: [ \"psg\", \"sgn\" ],\n\t            psl: [ \"psl\", \"sgn\" ], pso: [ \"pso\", \"sgn\" ], psp: [ \"psp\", \"sgn\" ], psr: [ \"psr\", \"sgn\" ],\n\t            pys: [ \"pys\", \"sgn\" ], rms: [ \"rms\", \"sgn\" ], rsi: [ \"rsi\", \"sgn\" ], rsl: [ \"rsl\", \"sgn\" ],\n\t            sdl: [ \"sdl\", \"sgn\" ], sfb: [ \"sfb\", \"sgn\" ], sfs: [ \"sfs\", \"sgn\" ], sgg: [ \"sgg\", \"sgn\" ],\n\t            sgx: [ \"sgx\", \"sgn\" ], shu: [ \"shu\", \"ar\"  ], slf: [ \"slf\", \"sgn\" ], sls: [ \"sls\", \"sgn\" ],\n\t            sqk: [ \"sqk\", \"sgn\" ], sqs: [ \"sqs\", \"sgn\" ], ssh: [ \"ssh\", \"ar\"  ], ssp: [ \"ssp\", \"sgn\" ],\n\t            ssr: [ \"ssr\", \"sgn\" ], svk: [ \"svk\", \"sgn\" ], swc: [ \"swc\", \"sw\"  ], swh: [ \"swh\", \"sw\"  ],\n\t            swl: [ \"swl\", \"sgn\" ], syy: [ \"syy\", \"sgn\" ], tmw: [ \"tmw\", \"ms\"  ], tse: [ \"tse\", \"sgn\" ],\n\t            tsm: [ \"tsm\", \"sgn\" ], tsq: [ \"tsq\", \"sgn\" ], tss: [ \"tss\", \"sgn\" ], tsy: [ \"tsy\", \"sgn\" ],\n\t            tza: [ \"tza\", \"sgn\" ], ugn: [ \"ugn\", \"sgn\" ], ugy: [ \"ugy\", \"sgn\" ], ukl: [ \"ukl\", \"sgn\" ],\n\t            uks: [ \"uks\", \"sgn\" ], urk: [ \"urk\", \"ms\"  ], uzn: [ \"uzn\", \"uz\"  ], uzs: [ \"uzs\", \"uz\"  ],\n\t            vgt: [ \"vgt\", \"sgn\" ], vkk: [ \"vkk\", \"ms\"  ], vkt: [ \"vkt\", \"ms\"  ], vsi: [ \"vsi\", \"sgn\" ],\n\t            vsl: [ \"vsl\", \"sgn\" ], vsv: [ \"vsv\", \"sgn\" ], wuu: [ \"wuu\", \"zh\"  ], xki: [ \"xki\", \"sgn\" ],\n\t            xml: [ \"xml\", \"sgn\" ], xmm: [ \"xmm\", \"ms\"  ], xms: [ \"xms\", \"sgn\" ], yds: [ \"yds\", \"sgn\" ],\n\t            ysl: [ \"ysl\", \"sgn\" ], yue: [ \"yue\", \"zh\"  ], zib: [ \"zib\", \"sgn\" ], zlm: [ \"zlm\", \"ms\"  ],\n\t            zmi: [ \"zmi\", \"ms\"  ], zsl: [ \"zsl\", \"sgn\" ], zsm: [ \"zsm\", \"ms\"  ]\n\t        }\n\t    },\n\t\n\t    // Currency minor units output from get-4217 grunt task, formatted\n\t    currencyMinorUnits = {\n\t        BHD: 3, BYR: 0, XOF: 0, BIF: 0, XAF: 0, CLF: 4, CLP: 0, KMF: 0, DJF: 0,\n\t        XPF: 0, GNF: 0, ISK: 0, IQD: 3, JPY: 0, JOD: 3, KRW: 0, KWD: 3, LYD: 3,\n\t        OMR: 3, PYG: 0, RWF: 0, TND: 3, UGX: 0, UYI: 0, VUV: 0, VND: 0\n\t    };\n\t\n\t// Sect 6.2 Language Tags\n\t// ======================\n\t\n\t/**\n\t * The IsStructurallyValidLanguageTag abstract operation verifies that the locale\n\t * argument (which must be a String value)\n\t *\n\t * - represents a well-formed BCP 47 language tag as specified in RFC 5646 section\n\t *   2.1, or successor,\n\t * - does not include duplicate variant subtags, and\n\t * - does not include duplicate singleton subtags.\n\t *\n\t * The abstract operation returns true if locale can be generated from the ABNF\n\t * grammar in section 2.1 of the RFC, starting with Language-Tag, and does not\n\t * contain duplicate variant or singleton subtags (other than as a private use\n\t * subtag). It returns false otherwise. Terminal value characters in the grammar are\n\t * interpreted as the Unicode equivalents of the ASCII octet values given.\n\t */\n\tfunction /* 6.2.2 */IsStructurallyValidLanguageTag(locale) {\n\t    // represents a well-formed BCP 47 language tag as specified in RFC 5646\n\t    if (!src$exp$$.expBCP47Syntax.test(locale))\n\t        return false;\n\t\n\t    // does not include duplicate variant subtags, and\n\t    if (src$exp$$.expVariantDupes.test(locale))\n\t        return false;\n\t\n\t    // does not include duplicate singleton subtags.\n\t    if (src$exp$$.expSingletonDupes.test(locale))\n\t        return false;\n\t\n\t    return true;\n\t}\n\t\n\t/**\n\t * The CanonicalizeLanguageTag abstract operation returns the canonical and case-\n\t * regularized form of the locale argument (which must be a String value that is\n\t * a structurally valid BCP 47 language tag as verified by the\n\t * IsStructurallyValidLanguageTag abstract operation). It takes the steps\n\t * specified in RFC 5646 section 4.5, or successor, to bring the language tag\n\t * into canonical form, and to regularize the case of the subtags, but does not\n\t * take the steps to bring a language tag into extlang form and to reorder\n\t * variant subtags.\n\t\n\t * The specifications for extensions to BCP 47 language tags, such as RFC 6067,\n\t * may include canonicalization rules for the extension subtag sequences they\n\t * define that go beyond the canonicalization rules of RFC 5646 section 4.5.\n\t * Implementations are allowed, but not required, to apply these additional rules.\n\t */\n\tfunction /* 6.2.3 */CanonicalizeLanguageTag (locale) {\n\t    var match, parts;\n\t\n\t    // A language tag is in 'canonical form' when the tag is well-formed\n\t    // according to the rules in Sections 2.1 and 2.2\n\t\n\t    // Section 2.1 says all subtags use lowercase...\n\t    locale = locale.toLowerCase();\n\t\n\t    // ...with 2 exceptions: 'two-letter and four-letter subtags that neither\n\t    // appear at the start of the tag nor occur after singletons.  Such two-letter\n\t    // subtags are all uppercase (as in the tags \"en-CA-x-ca\" or \"sgn-BE-FR\") and\n\t    // four-letter subtags are titlecase (as in the tag \"az-Latn-x-latn\").\n\t    parts = locale.split('-');\n\t    for (var i = 1, max = parts.length; i < max; i++) {\n\t        // Two-letter subtags are all uppercase\n\t        if (parts[i].length === 2)\n\t            parts[i] = parts[i].toUpperCase();\n\t\n\t        // Four-letter subtags are titlecase\n\t        else if (parts[i].length === 4)\n\t            parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].slice(1);\n\t\n\t        // Is it a singleton?\n\t        else if (parts[i].length === 1 && parts[i] !== 'x')\n\t            break;\n\t    }\n\t    locale = arrJoin.call(parts, '-');\n\t\n\t    // The steps laid out in RFC 5646 section 4.5 are as follows:\n\t\n\t    // 1.  Extension sequences are ordered into case-insensitive ASCII order\n\t    //     by singleton subtag.\n\t    if ((match = locale.match(src$exp$$.expExtSequences)) && match.length > 1) {\n\t        // The built-in sort() sorts by ASCII order, so use that\n\t        match.sort();\n\t\n\t        // Replace all extensions with the joined, sorted array\n\t        locale = locale.replace(\n\t            RegExp('(?:' + src$exp$$.expExtSequences.source + ')+', 'i'),\n\t            arrJoin.call(match, '')\n\t        );\n\t    }\n\t\n\t    // 2.  Redundant or grandfathered tags are replaced by their 'Preferred-\n\t    //     Value', if there is one.\n\t    if (hop.call(redundantTags.tags, locale))\n\t        locale = redundantTags.tags[locale];\n\t\n\t    // 3.  Subtags are replaced by their 'Preferred-Value', if there is one.\n\t    //     For extlangs, the original primary language subtag is also\n\t    //     replaced if there is a primary language subtag in the 'Preferred-\n\t    //     Value'.\n\t    parts = locale.split('-');\n\t\n\t    for (var i = 1, max = parts.length; i < max; i++) {\n\t        if (hop.call(redundantTags.subtags, parts[i]))\n\t            parts[i] = redundantTags.subtags[parts[i]];\n\t\n\t        else if (hop.call(redundantTags.extLang, parts[i])) {\n\t            parts[i] = redundantTags.extLang[parts[i]][0];\n\t\n\t            // For extlang tags, the prefix needs to be removed if it is redundant\n\t            if (i === 1 && redundantTags.extLang[parts[1]][1] === parts[0]) {\n\t                parts = arrSlice.call(parts, i++);\n\t                max -= 1;\n\t            }\n\t        }\n\t    }\n\t\n\t    return arrJoin.call(parts, '-');\n\t}\n\t\n\t/**\n\t * The DefaultLocale abstract operation returns a String value representing the\n\t * structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the\n\t * host environments current locale.\n\t */\n\tfunction /* 6.2.4 */DefaultLocale () {\n\t    return defaultLocale;\n\t}\n\t\n\t// Sect 6.3 Currency Codes\n\t// =======================\n\t\n\t/**\n\t * The IsWellFormedCurrencyCode abstract operation verifies that the currency argument\n\t * (after conversion to a String value) represents a well-formed 3-letter ISO currency\n\t * code. The following steps are taken:\n\t */\n\tfunction /* 6.3.1 */IsWellFormedCurrencyCode(currency) {\n\t    var\n\t        // 1. Let `c` be ToString(currency)\n\t        c = String(currency),\n\t\n\t        // 2. Let `normalized` be the result of mapping c to upper case as described\n\t        //    in 6.1.\n\t        normalized = toLatinUpperCase(c);\n\t\n\t    // 3. If the string length of normalized is not 3, return false.\n\t    // 4. If normalized contains any character that is not in the range \"A\" to \"Z\"\n\t    //    (U+0041 to U+005A), return false.\n\t    if (expCurrencyCode.test(normalized) === false)\n\t        return false;\n\t\n\t    // 5. Return true\n\t    return true;\n\t}\n\t\n\t// Sect 9.2 Abstract Operations\n\t// ============================\n\tfunction /* 9.2.1 */CanonicalizeLocaleList (locales) {\n\t// The abstract operation CanonicalizeLocaleList takes the following steps:\n\t\n\t    // 1. If locales is undefined, then a. Return a new empty List\n\t    if (locales === undefined)\n\t        return new List();\n\t\n\t    var\n\t        // 2. Let seen be a new empty List.\n\t        seen = new List(),\n\t\n\t        // 3. If locales is a String value, then\n\t        //    a. Let locales be a new array created as if by the expression new\n\t        //    Array(locales) where Array is the standard built-in constructor with\n\t        //    that name and locales is the value of locales.\n\t        locales = typeof locales === 'string' ? [ locales ] : locales,\n\t\n\t        // 4. Let O be ToObject(locales).\n\t        O = toObject(locales),\n\t\n\t        // 5. Let lenValue be the result of calling the [[Get]] internal method of\n\t        //    O with the argument \"length\".\n\t        // 6. Let len be ToUint32(lenValue).\n\t        len = O.length,\n\t\n\t        // 7. Let k be 0.\n\t        k = 0;\n\t\n\t    // 8. Repeat, while k < len\n\t    while (k < len) {\n\t        var\n\t            // a. Let Pk be ToString(k).\n\t            Pk = String(k),\n\t\n\t            // b. Let kPresent be the result of calling the [[HasProperty]] internal\n\t            //    method of O with argument Pk.\n\t            kPresent = Pk in O;\n\t\n\t        // c. If kPresent is true, then\n\t        if (kPresent) {\n\t            var\n\t                // i. Let kValue be the result of calling the [[Get]] internal\n\t                //     method of O with argument Pk.\n\t                kValue = O[Pk];\n\t\n\t            // ii. If the type of kValue is not String or Object, then throw a\n\t            //     TypeError exception.\n\t            if (kValue == null || (typeof kValue !== 'string' && typeof kValue !== 'object'))\n\t                throw new TypeError('String or Object type expected');\n\t\n\t            var\n\t                // iii. Let tag be ToString(kValue).\n\t                tag = String(kValue);\n\t\n\t            // iv. If the result of calling the abstract operation\n\t            //     IsStructurallyValidLanguageTag (defined in 6.2.2), passing tag as\n\t            //     the argument, is false, then throw a RangeError exception.\n\t            if (!IsStructurallyValidLanguageTag(tag))\n\t                throw new RangeError(\"'\" + tag + \"' is not a structurally valid language tag\");\n\t\n\t            // v. Let tag be the result of calling the abstract operation\n\t            //    CanonicalizeLanguageTag (defined in 6.2.3), passing tag as the\n\t            //    argument.\n\t            tag = CanonicalizeLanguageTag(tag);\n\t\n\t            // vi. If tag is not an element of seen, then append tag as the last\n\t            //     element of seen.\n\t            if (arrIndexOf.call(seen, tag) === -1)\n\t                arrPush.call(seen, tag);\n\t        }\n\t\n\t        // d. Increase k by 1.\n\t        k++;\n\t    }\n\t\n\t    // 9. Return seen.\n\t    return seen;\n\t}\n\t\n\t/**\n\t * The BestAvailableLocale abstract operation compares the provided argument\n\t * locale, which must be a String value with a structurally valid and\n\t * canonicalized BCP 47 language tag, against the locales in availableLocales and\n\t * returns either the longest non-empty prefix of locale that is an element of\n\t * availableLocales, or undefined if there is no such element. It uses the\n\t * fallback mechanism of RFC 4647, section 3.4. The following steps are taken:\n\t */\n\tfunction /* 9.2.2 */BestAvailableLocale (availableLocales, locale) {\n\t    var\n\t       // 1. Let candidate be locale\n\t       candidate = locale;\n\t\n\t    // 2. Repeat\n\t    while (true) {\n\t        // a. If availableLocales contains an element equal to candidate, then return\n\t        // candidate.\n\t        if (arrIndexOf.call(availableLocales, candidate) > -1)\n\t            return candidate;\n\t\n\t        var\n\t            // b. Let pos be the character index of the last occurrence of \"-\"\n\t            // (U+002D) within candidate. If that character does not occur, return\n\t            // undefined.\n\t            pos = candidate.lastIndexOf('-');\n\t\n\t        if (pos < 0)\n\t            return;\n\t\n\t        // c. If pos  2 and the character \"-\" occurs at index pos-2 of candidate,\n\t        //    then decrease pos by 2.\n\t        if (pos >= 2 && candidate.charAt(pos - 2) === '-')\n\t            pos -= 2;\n\t\n\t        // d. Let candidate be the substring of candidate from position 0, inclusive,\n\t        //    to position pos, exclusive.\n\t        candidate = candidate.substring(0, pos);\n\t    }\n\t}\n\t\n\t/**\n\t * The LookupMatcher abstract operation compares requestedLocales, which must be\n\t * a List as returned by CanonicalizeLocaleList, against the locales in\n\t * availableLocales and determines the best available language to meet the\n\t * request. The following steps are taken:\n\t */\n\tfunction /* 9.2.3 */LookupMatcher (availableLocales, requestedLocales) {\n\t    var\n\t        // 1. Let i be 0.\n\t        i = 0,\n\t\n\t        // 2. Let len be the number of elements in requestedLocales.\n\t        len = requestedLocales.length,\n\t\n\t        // 3. Let availableLocale be undefined.\n\t        availableLocale;\n\t\n\t    // 4. Repeat while i < len and availableLocale is undefined:\n\t    while (i < len && !availableLocale) {\n\t        var\n\t            // a. Let locale be the element of requestedLocales at 0-origined list\n\t            //    position i.\n\t            locale = requestedLocales[i],\n\t\n\t            // b. Let noExtensionsLocale be the String value that is locale with all\n\t            //    Unicode locale extension sequences removed.\n\t            noExtensionsLocale = String(locale).replace(expUnicodeExSeq, ''),\n\t\n\t            // c. Let availableLocale be the result of calling the\n\t            //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n\t            //    arguments availableLocales and noExtensionsLocale.\n\t            availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\t\n\t        // d. Increase i by 1.\n\t        i++;\n\t    }\n\t\n\t    var\n\t        // 5. Let result be a new Record.\n\t        result = new Record();\n\t\n\t    // 6. If availableLocale is not undefined, then\n\t    if (availableLocale !== undefined) {\n\t        // a. Set result.[[locale]] to availableLocale.\n\t        result['[[locale]]'] = availableLocale;\n\t\n\t        // b. If locale and noExtensionsLocale are not the same String value, then\n\t        if (String(locale) !== String(noExtensionsLocale)) {\n\t            var\n\t                // i. Let extension be the String value consisting of the first\n\t                //    substring of locale that is a Unicode locale extension sequence.\n\t                extension = locale.match(expUnicodeExSeq)[0],\n\t\n\t                // ii. Let extensionIndex be the character position of the initial\n\t                //     \"-\" of the first Unicode locale extension sequence within locale.\n\t                extensionIndex = locale.indexOf('-u-');\n\t\n\t            // iii. Set result.[[extension]] to extension.\n\t            result['[[extension]]'] = extension;\n\t\n\t            // iv. Set result.[[extensionIndex]] to extensionIndex.\n\t            result['[[extensionIndex]]'] = extensionIndex;\n\t        }\n\t    }\n\t    // 7. Else\n\t    else\n\t        // a. Set result.[[locale]] to the value returned by the DefaultLocale abstract\n\t        //    operation (defined in 6.2.4).\n\t        result['[[locale]]'] = DefaultLocale();\n\t\n\t    // 8. Return result\n\t    return result;\n\t}\n\t\n\t/**\n\t * The BestFitMatcher abstract operation compares requestedLocales, which must be\n\t * a List as returned by CanonicalizeLocaleList, against the locales in\n\t * availableLocales and determines the best available language to meet the\n\t * request. The algorithm is implementation dependent, but should produce results\n\t * that a typical user of the requested locales would perceive as at least as\n\t * good as those produced by the LookupMatcher abstract operation. Options\n\t * specified through Unicode locale extension sequences must be ignored by the\n\t * algorithm. Information about such subsequences is returned separately.\n\t * The abstract operation returns a record with a [[locale]] field, whose value\n\t * is the language tag of the selected locale, which must be an element of\n\t * availableLocales. If the language tag of the request locale that led to the\n\t * selected locale contained a Unicode locale extension sequence, then the\n\t * returned record also contains an [[extension]] field whose value is the first\n\t * Unicode locale extension sequence, and an [[extensionIndex]] field whose value\n\t * is the index of the first Unicode locale extension sequence within the request\n\t * locale language tag.\n\t */\n\tfunction /* 9.2.4 */BestFitMatcher (availableLocales, requestedLocales) {\n\t    return LookupMatcher(availableLocales, requestedLocales);\n\t}\n\t\n\t/**\n\t * The ResolveLocale abstract operation compares a BCP 47 language priority list\n\t * requestedLocales against the locales in availableLocales and determines the\n\t * best available language to meet the request. availableLocales and\n\t * requestedLocales must be provided as List values, options as a Record.\n\t */\n\tfunction /* 9.2.5 */ResolveLocale (availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {\n\t    if (availableLocales.length === 0) {\n\t        throw new ReferenceError('No locale data has been provided for this object yet.');\n\t    }\n\t\n\t    // The following steps are taken:\n\t    var\n\t        // 1. Let matcher be the value of options.[[localeMatcher]].\n\t        matcher = options['[[localeMatcher]]'];\n\t\n\t    // 2. If matcher is \"lookup\", then\n\t    if (matcher === 'lookup')\n\t        var\n\t            // a. Let r be the result of calling the LookupMatcher abstract operation\n\t            //    (defined in 9.2.3) with arguments availableLocales and\n\t            //    requestedLocales.\n\t            r = LookupMatcher(availableLocales, requestedLocales);\n\t\n\t    // 3. Else\n\t    else\n\t        var\n\t            // a. Let r be the result of calling the BestFitMatcher abstract\n\t            //    operation (defined in 9.2.4) with arguments availableLocales and\n\t            //    requestedLocales.\n\t            r = BestFitMatcher(availableLocales, requestedLocales);\n\t\n\t    var\n\t        // 4. Let foundLocale be the value of r.[[locale]].\n\t        foundLocale = r['[[locale]]'];\n\t\n\t    // 5. If r has an [[extension]] field, then\n\t    if (hop.call(r, '[[extension]]'))\n\t        var\n\t            // a. Let extension be the value of r.[[extension]].\n\t            extension = r['[[extension]]'],\n\t            // b. Let extensionIndex be the value of r.[[extensionIndex]].\n\t            extensionIndex = r['[[extensionIndex]]'],\n\t            // c. Let split be the standard built-in function object defined in ES5,\n\t            //    15.5.4.14.\n\t            split = String.prototype.split,\n\t            // d. Let extensionSubtags be the result of calling the [[Call]] internal\n\t            //    method of split with extension as the this value and an argument\n\t            //    list containing the single item \"-\".\n\t            extensionSubtags = split.call(extension, '-'),\n\t            // e. Let extensionSubtagsLength be the result of calling the [[Get]]\n\t            //    internal method of extensionSubtags with argument \"length\".\n\t            extensionSubtagsLength = extensionSubtags.length;\n\t\n\t    var\n\t        // 6. Let result be a new Record.\n\t        result = new Record();\n\t\n\t    // 7. Set result.[[dataLocale]] to foundLocale.\n\t    result['[[dataLocale]]'] = foundLocale;\n\t\n\t    var\n\t        // 8. Let supportedExtension be \"-u\".\n\t        supportedExtension = '-u',\n\t        // 9. Let i be 0.\n\t        i = 0,\n\t        // 10. Let len be the result of calling the [[Get]] internal method of\n\t        //     relevantExtensionKeys with argument \"length\".\n\t        len = relevantExtensionKeys.length;\n\t\n\t    // 11 Repeat while i < len:\n\t    while (i < len) {\n\t        var\n\t            // a. Let key be the result of calling the [[Get]] internal method of\n\t            //    relevantExtensionKeys with argument ToString(i).\n\t            key = relevantExtensionKeys[i],\n\t            // b. Let foundLocaleData be the result of calling the [[Get]] internal\n\t            //    method of localeData with the argument foundLocale.\n\t            foundLocaleData = localeData[foundLocale],\n\t            // c. Let keyLocaleData be the result of calling the [[Get]] internal\n\t            //    method of foundLocaleData with the argument key.\n\t            keyLocaleData = foundLocaleData[key],\n\t            // d. Let value be the result of calling the [[Get]] internal method of\n\t            //    keyLocaleData with argument \"0\".\n\t            value = keyLocaleData['0'],\n\t            // e. Let supportedExtensionAddition be \"\".\n\t            supportedExtensionAddition = '',\n\t            // f. Let indexOf be the standard built-in function object defined in\n\t            //    ES5, 15.4.4.14.\n\t            indexOf = arrIndexOf;\n\t\n\t        // g. If extensionSubtags is not undefined, then\n\t        if (extensionSubtags !== undefined) {\n\t            var\n\t                // i. Let keyPos be the result of calling the [[Call]] internal\n\t                //    method of indexOf with extensionSubtags as the this value and\n\t                // an argument list containing the single item key.\n\t                keyPos = indexOf.call(extensionSubtags, key);\n\t\n\t            // ii. If keyPos  -1, then\n\t            if (keyPos !== -1) {\n\t                // 1. If keyPos + 1 < extensionSubtagsLength and the length of the\n\t                //    result of calling the [[Get]] internal method of\n\t                //    extensionSubtags with argument ToString(keyPos +1) is greater\n\t                //    than 2, then\n\t                if (keyPos + 1 < extensionSubtagsLength\n\t                        && extensionSubtags[keyPos + 1].length > 2) {\n\t                    var\n\t                        // a. Let requestedValue be the result of calling the [[Get]]\n\t                        //    internal method of extensionSubtags with argument\n\t                        //    ToString(keyPos + 1).\n\t                        requestedValue = extensionSubtags[keyPos + 1],\n\t                        // b. Let valuePos be the result of calling the [[Call]]\n\t                        //    internal method of indexOf with keyLocaleData as the\n\t                        //    this value and an argument list containing the single\n\t                        //    item requestedValue.\n\t                        valuePos = indexOf.call(keyLocaleData, requestedValue);\n\t\n\t                    // c. If valuePos  -1, then\n\t                    if (valuePos !== -1)\n\t                        var\n\t                            // i. Let value be requestedValue.\n\t                            value = requestedValue,\n\t                            // ii. Let supportedExtensionAddition be the\n\t                            //     concatenation of \"-\", key, \"-\", and value.\n\t                            supportedExtensionAddition = '-' + key + '-' + value;\n\t                }\n\t                // 2. Else\n\t                else {\n\t                    var\n\t                        // a. Let valuePos be the result of calling the [[Call]]\n\t                        // internal method of indexOf with keyLocaleData as the this\n\t                        // value and an argument list containing the single item\n\t                        // \"true\".\n\t                        valuePos = indexOf(keyLocaleData, 'true');\n\t\n\t                    // b. If valuePos  -1, then\n\t                    if (valuePos !== -1)\n\t                        var\n\t                            // i. Let value be \"true\".\n\t                            value = 'true';\n\t                }\n\t            }\n\t        }\n\t        // h. If options has a field [[<key>]], then\n\t        if (hop.call(options, '[[' + key + ']]')) {\n\t            var\n\t                // i. Let optionsValue be the value of options.[[<key>]].\n\t                optionsValue = options['[[' + key + ']]'];\n\t\n\t            // ii. If the result of calling the [[Call]] internal method of indexOf\n\t            //     with keyLocaleData as the this value and an argument list\n\t            //     containing the single item optionsValue is not -1, then\n\t            if (indexOf.call(keyLocaleData, optionsValue) !== -1) {\n\t                // 1. If optionsValue is not equal to value, then\n\t                if (optionsValue !== value) {\n\t                    // a. Let value be optionsValue.\n\t                    value = optionsValue;\n\t                    // b. Let supportedExtensionAddition be \"\".\n\t                    supportedExtensionAddition = '';\n\t                }\n\t            }\n\t        }\n\t        // i. Set result.[[<key>]] to value.\n\t        result['[[' + key + ']]'] = value;\n\t\n\t        // j. Append supportedExtensionAddition to supportedExtension.\n\t        supportedExtension += supportedExtensionAddition;\n\t\n\t        // k. Increase i by 1.\n\t        i++;\n\t    }\n\t    // 12. If the length of supportedExtension is greater than 2, then\n\t    if (supportedExtension.length > 2) {\n\t        var\n\t            // a. Let preExtension be the substring of foundLocale from position 0,\n\t            //    inclusive, to position extensionIndex, exclusive.\n\t            preExtension = foundLocale.substring(0, extensionIndex),\n\t            // b. Let postExtension be the substring of foundLocale from position\n\t            //    extensionIndex to the end of the string.\n\t            postExtension = foundLocale.substring(extensionIndex),\n\t            // c. Let foundLocale be the concatenation of preExtension,\n\t            //    supportedExtension, and postExtension.\n\t            foundLocale = preExtension + supportedExtension + postExtension;\n\t    }\n\t    // 13. Set result.[[locale]] to foundLocale.\n\t    result['[[locale]]'] = foundLocale;\n\t\n\t    // 14. Return result.\n\t    return result;\n\t}\n\t\n\t/**\n\t * The LookupSupportedLocales abstract operation returns the subset of the\n\t * provided BCP 47 language priority list requestedLocales for which\n\t * availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n\t * Locales appear in the same order in the returned list as in requestedLocales.\n\t * The following steps are taken:\n\t */\n\tfunction /* 9.2.6 */LookupSupportedLocales (availableLocales, requestedLocales) {\n\t    var\n\t        // 1. Let len be the number of elements in requestedLocales.\n\t        len = requestedLocales.length,\n\t        // 2. Let subset be a new empty List.\n\t        subset = new List(),\n\t        // 3. Let k be 0.\n\t        k = 0;\n\t\n\t    // 4. Repeat while k < len\n\t    while (k < len) {\n\t        var\n\t            // a. Let locale be the element of requestedLocales at 0-origined list\n\t            //    position k.\n\t            locale = requestedLocales[k],\n\t            // b. Let noExtensionsLocale be the String value that is locale with all\n\t            //    Unicode locale extension sequences removed.\n\t            noExtensionsLocale = String(locale).replace(expUnicodeExSeq, ''),\n\t            // c. Let availableLocale be the result of calling the\n\t            //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n\t            //    arguments availableLocales and noExtensionsLocale.\n\t            availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\t\n\t        // d. If availableLocale is not undefined, then append locale to the end of\n\t        //    subset.\n\t        if (availableLocale !== undefined)\n\t            arrPush.call(subset, locale);\n\t\n\t        // e. Increment k by 1.\n\t        k++;\n\t    }\n\t\n\t    var\n\t        // 5. Let subsetArray be a new Array object whose elements are the same\n\t        //    values in the same order as the elements of subset.\n\t        subsetArray = arrSlice.call(subset);\n\t\n\t    // 6. Return subsetArray.\n\t    return subsetArray;\n\t}\n\t\n\t/**\n\t * The BestFitSupportedLocales abstract operation returns the subset of the\n\t * provided BCP 47 language priority list requestedLocales for which\n\t * availableLocales has a matching locale when using the Best Fit Matcher\n\t * algorithm. Locales appear in the same order in the returned list as in\n\t * requestedLocales. The steps taken are implementation dependent.\n\t */\n\tfunction /*9.2.7 */BestFitSupportedLocales (availableLocales, requestedLocales) {\n\t    // ###TODO: implement this function as described by the specification###\n\t    return LookupSupportedLocales(availableLocales, requestedLocales);\n\t}\n\t\n\t/**\n\t * The SupportedLocales abstract operation returns the subset of the provided BCP\n\t * 47 language priority list requestedLocales for which availableLocales has a\n\t * matching locale. Two algorithms are available to match the locales: the Lookup\n\t * algorithm described in RFC 4647 section 3.4, and an implementation dependent\n\t * best-fit algorithm. Locales appear in the same order in the returned list as\n\t * in requestedLocales. The following steps are taken:\n\t */\n\tfunction /*9.2.8 */SupportedLocales (availableLocales, requestedLocales, options) {\n\t    // 1. If options is not undefined, then\n\t    if (options !== undefined) {\n\t        var\n\t            // a. Let options be ToObject(options).\n\t            options = new Record(toObject(options)),\n\t            // b. Let matcher be the result of calling the [[Get]] internal method of\n\t            //    options with argument \"localeMatcher\".\n\t            matcher = options.localeMatcher;\n\t\n\t        // c. If matcher is not undefined, then\n\t        if (matcher !== undefined) {\n\t            // i. Let matcher be ToString(matcher).\n\t            matcher = String(matcher);\n\t\n\t            // ii. If matcher is not \"lookup\" or \"best fit\", then throw a RangeError\n\t            //     exception.\n\t            if (matcher !== 'lookup' && matcher !== 'best fit')\n\t                throw new RangeError('matcher should be \"lookup\" or \"best fit\"');\n\t        }\n\t    }\n\t    // 2. If matcher is undefined or \"best fit\", then\n\t    if (matcher === undefined || matcher === 'best fit')\n\t        var\n\t            // a. Let subset be the result of calling the BestFitSupportedLocales\n\t            //    abstract operation (defined in 9.2.7) with arguments\n\t            //    availableLocales and requestedLocales.\n\t            subset = BestFitSupportedLocales(availableLocales, requestedLocales);\n\t    // 3. Else\n\t    else\n\t        var\n\t            // a. Let subset be the result of calling the LookupSupportedLocales\n\t            //    abstract operation (defined in 9.2.6) with arguments\n\t            //    availableLocales and requestedLocales.\n\t            subset = LookupSupportedLocales(availableLocales, requestedLocales);\n\t\n\t    // 4. For each named own property name P of subset,\n\t    for (var P in subset) {\n\t        if (!hop.call(subset, P))\n\t            continue;\n\t\n\t        // a. Let desc be the result of calling the [[GetOwnProperty]] internal\n\t        //    method of subset with P.\n\t        // b. Set desc.[[Writable]] to false.\n\t        // c. Set desc.[[Configurable]] to false.\n\t        // d. Call the [[DefineOwnProperty]] internal method of subset with P, desc,\n\t        //    and true as arguments.\n\t        defineProperty(subset, P, {\n\t            writable: false, configurable: false, value: subset[P]\n\t        });\n\t    }\n\t    // \"Freeze\" the array so no new elements can be added\n\t    defineProperty(subset, 'length', { writable: false });\n\t\n\t    // 5. Return subset\n\t    return subset;\n\t}\n\t\n\t/**\n\t * The GetOption abstract operation extracts the value of the property named\n\t * property from the provided options object, converts it to the required type,\n\t * checks whether it is one of a List of allowed values, and fills in a fallback\n\t * value if necessary.\n\t */\n\tfunction /*9.2.9 */GetOption (options, property, type, values, fallback) {\n\t    var\n\t        // 1. Let value be the result of calling the [[Get]] internal method of\n\t        //    options with argument property.\n\t        value = options[property];\n\t\n\t    // 2. If value is not undefined, then\n\t    if (value !== undefined) {\n\t        // a. Assert: type is \"boolean\" or \"string\".\n\t        // b. If type is \"boolean\", then let value be ToBoolean(value).\n\t        // c. If type is \"string\", then let value be ToString(value).\n\t        value = type === 'boolean' ? Boolean(value)\n\t                  : (type === 'string' ? String(value) : value);\n\t\n\t        // d. If values is not undefined, then\n\t        if (values !== undefined) {\n\t            // i. If values does not contain an element equal to value, then throw a\n\t            //    RangeError exception.\n\t            if (arrIndexOf.call(values, value) === -1)\n\t                throw new RangeError(\"'\" + value + \"' is not an allowed value for `\" + property +'`');\n\t        }\n\t\n\t        // e. Return value.\n\t        return value;\n\t    }\n\t    // Else return fallback.\n\t    return fallback;\n\t}\n\t\n\t/**\n\t * The GetNumberOption abstract operation extracts a property value from the\n\t * provided options object, converts it to a Number value, checks whether it is\n\t * in the allowed range, and fills in a fallback value if necessary.\n\t */\n\tfunction /* 9.2.10 */GetNumberOption (options, property, minimum, maximum, fallback) {\n\t    var\n\t        // 1. Let value be the result of calling the [[Get]] internal method of\n\t        //    options with argument property.\n\t        value = options[property];\n\t\n\t    // 2. If value is not undefined, then\n\t    if (value !== undefined) {\n\t        // a. Let value be ToNumber(value).\n\t        value = Number(value);\n\t\n\t        // b. If value is NaN or less than minimum or greater than maximum, throw a\n\t        //    RangeError exception.\n\t        if (isNaN(value) || value < minimum || value > maximum)\n\t            throw new RangeError('Value is not a number or outside accepted range');\n\t\n\t        // c. Return floor(value).\n\t        return Math.floor(value);\n\t    }\n\t    // 3. Else return fallback.\n\t    return fallback;\n\t}\n\t\n\t// 11.1 The Intl.NumberFormat constructor\n\t// ======================================\n\t\n\t// Define the NumberFormat constructor internally so it cannot be tainted\n\tfunction NumberFormatConstructor () {\n\t    var locales = arguments[0];\n\t    var options = arguments[1];\n\t\n\t    if (!this || this === Intl) {\n\t        return new Intl.NumberFormat(locales, options);\n\t    }\n\t\n\t    return InitializeNumberFormat(toObject(this), locales, options);\n\t}\n\t\n\tdefineProperty(Intl, 'NumberFormat', {\n\t    configurable: true,\n\t    writable: true,\n\t    value: NumberFormatConstructor\n\t});\n\t\n\t// Must explicitly set prototypes as unwritable\n\tdefineProperty(Intl.NumberFormat, 'prototype', {\n\t    writable: false\n\t});\n\t\n\t/**\n\t * The abstract operation InitializeNumberFormat accepts the arguments\n\t * numberFormat (which must be an object), locales, and options. It initializes\n\t * numberFormat as a NumberFormat object.\n\t */\n\tfunction /*11.1.1.1 */InitializeNumberFormat (numberFormat, locales, options) {\n\t    var\n\t    // This will be a internal properties object if we're not already initialized\n\t        internal = getInternalProperties(numberFormat),\n\t\n\t    // Create an object whose props can be used to restore the values of RegExp props\n\t        regexpState = createRegExpRestore();\n\t\n\t    // 1. If numberFormat has an [[initializedIntlObject]] internal property with\n\t    // value true, throw a TypeError exception.\n\t    if (internal['[[initializedIntlObject]]'] === true)\n\t        throw new TypeError('`this` object has already been initialized as an Intl object');\n\t\n\t    // Need this to access the `internal` object\n\t    defineProperty(numberFormat, '__getInternalProperties', {\n\t        value: function () {\n\t            // NOTE: Non-standard, for internal use only\n\t            if (arguments[0] === secret)\n\t                return internal;\n\t        }\n\t    });\n\t\n\t    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n\t    internal['[[initializedIntlObject]]'] = true;\n\t\n\t    var\n\t    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n\t    //    abstract operation (defined in 9.2.1) with argument locales.\n\t        requestedLocales = CanonicalizeLocaleList(locales);\n\t\n\t    // 4. If options is undefined, then\n\t    if (options === undefined)\n\t        // a. Let options be the result of creating a new object as if by the\n\t        // expression new Object() where Object is the standard built-in constructor\n\t        // with that name.\n\t        options = {};\n\t\n\t    // 5. Else\n\t    else\n\t        // a. Let options be ToObject(options).\n\t        options = toObject(options);\n\t\n\t    var\n\t    // 6. Let opt be a new Record.\n\t        opt = new Record(),\n\t\n\t    // 7. Let matcher be the result of calling the GetOption abstract operation\n\t    //    (defined in 9.2.9) with the arguments options, \"localeMatcher\", \"string\",\n\t    //    a List containing the two String values \"lookup\" and \"best fit\", and\n\t    //    \"best fit\".\n\t        matcher =  GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\t\n\t    // 8. Set opt.[[localeMatcher]] to matcher.\n\t    opt['[[localeMatcher]]'] = matcher;\n\t\n\t    var\n\t    // 9. Let NumberFormat be the standard built-in object that is the initial value\n\t    //    of Intl.NumberFormat.\n\t    // 10. Let localeData be the value of the [[localeData]] internal property of\n\t    //     NumberFormat.\n\t        localeData = internals.NumberFormat['[[localeData]]'],\n\t\n\t    // 11. Let r be the result of calling the ResolveLocale abstract operation\n\t    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n\t    //     NumberFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n\t    //     internal property of NumberFormat, and localeData.\n\t        r = ResolveLocale(\n\t                internals.NumberFormat['[[availableLocales]]'], requestedLocales,\n\t                opt, internals.NumberFormat['[[relevantExtensionKeys]]'], localeData\n\t            );\n\t\n\t    // 12. Set the [[locale]] internal property of numberFormat to the value of\n\t    //     r.[[locale]].\n\t    internal['[[locale]]'] = r['[[locale]]'];\n\t\n\t    // 13. Set the [[numberingSystem]] internal property of numberFormat to the value\n\t    //     of r.[[nu]].\n\t    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\t\n\t    // The specification doesn't tell us to do this, but it's helpful later on\n\t    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\t\n\t    var\n\t    // 14. Let dataLocale be the value of r.[[dataLocale]].\n\t        dataLocale = r['[[dataLocale]]'],\n\t\n\t    // 15. Let s be the result of calling the GetOption abstract operation with the\n\t    //     arguments options, \"style\", \"string\", a List containing the three String\n\t    //     values \"decimal\", \"percent\", and \"currency\", and \"decimal\".\n\t        s = GetOption(options, 'style', 'string', new List('decimal', 'percent', 'currency'), 'decimal');\n\t\n\t    // 16. Set the [[style]] internal property of numberFormat to s.\n\t    internal['[[style]]'] = s;\n\t\n\t    var\n\t    // 17. Let c be the result of calling the GetOption abstract operation with the\n\t    //     arguments options, \"currency\", \"string\", undefined, and undefined.\n\t        c = GetOption(options, 'currency', 'string');\n\t\n\t    // 18. If c is not undefined and the result of calling the\n\t    //     IsWellFormedCurrencyCode abstract operation (defined in 6.3.1) with\n\t    //     argument c is false, then throw a RangeError exception.\n\t    if (c !== undefined && !IsWellFormedCurrencyCode(c))\n\t        throw new RangeError(\"'\" + c + \"' is not a valid currency code\");\n\t\n\t    // 19. If s is \"currency\" and c is undefined, throw a TypeError exception.\n\t    if (s === 'currency' && c === undefined)\n\t        throw new TypeError('Currency code is required when style is currency');\n\t\n\t    // 20. If s is \"currency\", then\n\t    if (s === 'currency') {\n\t        // a. Let c be the result of converting c to upper case as specified in 6.1.\n\t        c = c.toUpperCase();\n\t\n\t        // b. Set the [[currency]] internal property of numberFormat to c.\n\t        internal['[[currency]]'] = c;\n\t\n\t        var\n\t        // c. Let cDigits be the result of calling the CurrencyDigits abstract\n\t        //    operation (defined below) with argument c.\n\t            cDigits = CurrencyDigits(c);\n\t    }\n\t\n\t    var\n\t    // 21. Let cd be the result of calling the GetOption abstract operation with the\n\t    //     arguments options, \"currencyDisplay\", \"string\", a List containing the\n\t    //     three String values \"code\", \"symbol\", and \"name\", and \"symbol\".\n\t        cd = GetOption(options, 'currencyDisplay', 'string', new List('code', 'symbol', 'name'), 'symbol');\n\t\n\t    // 22. If s is \"currency\", then set the [[currencyDisplay]] internal property of\n\t    //     numberFormat to cd.\n\t    if (s === 'currency')\n\t        internal['[[currencyDisplay]]'] = cd;\n\t\n\t    var\n\t    // 23. Let mnid be the result of calling the GetNumberOption abstract operation\n\t    //     (defined in 9.2.10) with arguments options, \"minimumIntegerDigits\", 1, 21,\n\t    //     and 1.\n\t        mnid = GetNumberOption(options, 'minimumIntegerDigits', 1, 21, 1);\n\t\n\t    // 24. Set the [[minimumIntegerDigits]] internal property of numberFormat to mnid.\n\t    internal['[[minimumIntegerDigits]]'] = mnid;\n\t\n\t    var\n\t    // 25. If s is \"currency\", then let mnfdDefault be cDigits; else let mnfdDefault\n\t    //     be 0.\n\t        mnfdDefault = s === 'currency' ? cDigits : 0,\n\t\n\t    // 26. Let mnfd be the result of calling the GetNumberOption abstract operation\n\t    //     with arguments options, \"minimumFractionDigits\", 0, 20, and mnfdDefault.\n\t        mnfd = GetNumberOption(options, 'minimumFractionDigits', 0, 20, mnfdDefault);\n\t\n\t    // 27. Set the [[minimumFractionDigits]] internal property of numberFormat to mnfd.\n\t    internal['[[minimumFractionDigits]]'] = mnfd;\n\t\n\t    var\n\t    // 28. If s is \"currency\", then let mxfdDefault be max(mnfd, cDigits); else if s\n\t    //     is \"percent\", then let mxfdDefault be max(mnfd, 0); else let mxfdDefault\n\t    //     be max(mnfd, 3).\n\t        mxfdDefault = s === 'currency' ? Math.max(mnfd, cDigits)\n\t                    : (s === 'percent' ? Math.max(mnfd, 0) : Math.max(mnfd, 3)),\n\t\n\t    // 29. Let mxfd be the result of calling the GetNumberOption abstract operation\n\t    //     with arguments options, \"maximumFractionDigits\", mnfd, 20, and mxfdDefault.\n\t        mxfd = GetNumberOption(options, 'maximumFractionDigits', mnfd, 20, mxfdDefault);\n\t\n\t    // 30. Set the [[maximumFractionDigits]] internal property of numberFormat to mxfd.\n\t    internal['[[maximumFractionDigits]]'] = mxfd;\n\t\n\t    var\n\t    // 31. Let mnsd be the result of calling the [[Get]] internal method of options\n\t    //     with argument \"minimumSignificantDigits\".\n\t        mnsd = options.minimumSignificantDigits,\n\t\n\t    // 32. Let mxsd be the result of calling the [[Get]] internal method of options\n\t    //     with argument \"maximumSignificantDigits\".\n\t        mxsd = options.maximumSignificantDigits;\n\t\n\t    // 33. If mnsd is not undefined or mxsd is not undefined, then:\n\t    if (mnsd !== undefined || mxsd !== undefined) {\n\t        // a. Let mnsd be the result of calling the GetNumberOption abstract\n\t        //    operation with arguments options, \"minimumSignificantDigits\", 1, 21,\n\t        //    and 1.\n\t        mnsd = GetNumberOption(options, 'minimumSignificantDigits', 1, 21, 1);\n\t\n\t        // b. Let mxsd be the result of calling the GetNumberOption abstract\n\t        //     operation with arguments options, \"maximumSignificantDigits\", mnsd,\n\t        //     21, and 21.\n\t        mxsd = GetNumberOption(options, 'maximumSignificantDigits', mnsd, 21, 21);\n\t\n\t        // c. Set the [[minimumSignificantDigits]] internal property of numberFormat\n\t        //    to mnsd, and the [[maximumSignificantDigits]] internal property of\n\t        //    numberFormat to mxsd.\n\t        internal['[[minimumSignificantDigits]]'] = mnsd;\n\t        internal['[[maximumSignificantDigits]]'] = mxsd;\n\t    }\n\t    var\n\t    // 34. Let g be the result of calling the GetOption abstract operation with the\n\t    //     arguments options, \"useGrouping\", \"boolean\", undefined, and true.\n\t        g = GetOption(options, 'useGrouping', 'boolean', undefined, true);\n\t\n\t    // 35. Set the [[useGrouping]] internal property of numberFormat to g.\n\t    internal['[[useGrouping]]'] = g;\n\t\n\t    var\n\t    // 36. Let dataLocaleData be the result of calling the [[Get]] internal method of\n\t    //     localeData with argument dataLocale.\n\t        dataLocaleData = localeData[dataLocale],\n\t\n\t    // 37. Let patterns be the result of calling the [[Get]] internal method of\n\t    //     dataLocaleData with argument \"patterns\".\n\t        patterns = dataLocaleData.patterns;\n\t\n\t    // 38. Assert: patterns is an object (see 11.2.3)\n\t\n\t    var\n\t    // 39. Let stylePatterns be the result of calling the [[Get]] internal method of\n\t    //     patterns with argument s.\n\t        stylePatterns = patterns[s];\n\t\n\t    // 40. Set the [[positivePattern]] internal property of numberFormat to the\n\t    //     result of calling the [[Get]] internal method of stylePatterns with the\n\t    //     argument \"positivePattern\".\n\t    internal['[[positivePattern]]'] = stylePatterns.positivePattern;\n\t\n\t    // 41. Set the [[negativePattern]] internal property of numberFormat to the\n\t    //     result of calling the [[Get]] internal method of stylePatterns with the\n\t    //     argument \"negativePattern\".\n\t    internal['[[negativePattern]]'] = stylePatterns.negativePattern;\n\t\n\t    // 42. Set the [[boundFormat]] internal property of numberFormat to undefined.\n\t    internal['[[boundFormat]]'] = undefined;\n\t\n\t    // 43. Set the [[initializedNumberFormat]] internal property of numberFormat to\n\t    //     true.\n\t    internal['[[initializedNumberFormat]]'] = true;\n\t\n\t    // In ES3, we need to pre-bind the format() function\n\t    if (es3)\n\t        numberFormat.format = GetFormatNumber.call(numberFormat);\n\t\n\t    // Restore the RegExp properties\n\t    regexpState.exp.test(regexpState.input);\n\t\n\t    // Return the newly initialised object\n\t    return numberFormat;\n\t}\n\t\n\tfunction CurrencyDigits(currency) {\n\t    // When the CurrencyDigits abstract operation is called with an argument currency\n\t    // (which must be an upper case String value), the following steps are taken:\n\t\n\t    // 1. If the ISO 4217 currency and funds code list contains currency as an\n\t    // alphabetic code, then return the minor unit value corresponding to the\n\t    // currency from the list; else return 2.\n\t    return currencyMinorUnits[currency] !== undefined\n\t                ? currencyMinorUnits[currency]\n\t                : 2;\n\t}\n\t\n\t/* 11.2.3 */internals.NumberFormat = {\n\t    '[[availableLocales]]': [],\n\t    '[[relevantExtensionKeys]]': ['nu'],\n\t    '[[localeData]]': {}\n\t};\n\t\n\t/**\n\t * When the supportedLocalesOf method of Intl.NumberFormat is called, the\n\t * following steps are taken:\n\t */\n\t/* 11.2.2 */defineProperty(Intl.NumberFormat, 'supportedLocalesOf', {\n\t    configurable: true,\n\t    writable: true,\n\t    value: fnBind.call(supportedLocalesOf, internals.NumberFormat)\n\t});\n\t\n\t/**\n\t * This named accessor property returns a function that formats a number\n\t * according to the effective locale and the formatting options of this\n\t * NumberFormat object.\n\t */\n\t/* 11.3.2 */defineProperty(Intl.NumberFormat.prototype, 'format', {\n\t    configurable: true,\n\t    get: GetFormatNumber\n\t});\n\t\n\tfunction GetFormatNumber() {\n\t        var internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\t\n\t        // Satisfy test 11.3_b\n\t        if (!internal || !internal['[[initializedNumberFormat]]'])\n\t            throw new TypeError('`this` value for format() is not an initialized Intl.NumberFormat object.');\n\t\n\t        // The value of the [[Get]] attribute is a function that takes the following\n\t        // steps:\n\t\n\t        // 1. If the [[boundFormat]] internal property of this NumberFormat object\n\t        //    is undefined, then:\n\t        if (internal['[[boundFormat]]'] === undefined) {\n\t            var\n\t            // a. Let F be a Function object, with internal properties set as\n\t            //    specified for built-in functions in ES5, 15, or successor, and the\n\t            //    length property set to 1, that takes the argument value and\n\t            //    performs the following steps:\n\t                F = function (value) {\n\t                    // i. If value is not provided, then let value be undefined.\n\t                    // ii. Let x be ToNumber(value).\n\t                    // iii. Return the result of calling the FormatNumber abstract\n\t                    //      operation (defined below) with arguments this and x.\n\t                    return FormatNumber(this, /* x = */Number(value));\n\t                },\n\t\n\t            // b. Let bind be the standard built-in function object defined in ES5,\n\t            //    15.3.4.5.\n\t            // c. Let bf be the result of calling the [[Call]] internal method of\n\t            //    bind with F as the this value and an argument list containing\n\t            //    the single item this.\n\t                bf = fnBind.call(F, this);\n\t\n\t            // d. Set the [[boundFormat]] internal property of this NumberFormat\n\t            //    object to bf.\n\t            internal['[[boundFormat]]'] = bf;\n\t        }\n\t        // Return the value of the [[boundFormat]] internal property of this\n\t        // NumberFormat object.\n\t        return internal['[[boundFormat]]'];\n\t    }\n\t\n\t/**\n\t * When the FormatNumber abstract operation is called with arguments numberFormat\n\t * (which must be an object initialized as a NumberFormat) and x (which must be a\n\t * Number value), it returns a String value representing x according to the\n\t * effective locale and the formatting options of numberFormat.\n\t */\n\tfunction FormatNumber (numberFormat, x) {\n\t    var n,\n\t\n\t    // Create an object whose props can be used to restore the values of RegExp props\n\t        regexpState = createRegExpRestore(),\n\t\n\t        internal = getInternalProperties(numberFormat),\n\t        locale = internal['[[dataLocale]]'],\n\t        nums   = internal['[[numberingSystem]]'],\n\t        data   = internals.NumberFormat['[[localeData]]'][locale],\n\t        ild    = data.symbols[nums] || data.symbols.latn,\n\t\n\t    // 1. Let negative be false.\n\t        negative = false;\n\t\n\t    // 2. If the result of isFinite(x) is false, then\n\t    if (isFinite(x) === false) {\n\t        // a. If x is NaN, then let n be an ILD String value indicating the NaN value.\n\t        if (isNaN(x))\n\t            n = ild.nan;\n\t\n\t        // b. Else\n\t        else {\n\t            // a. Let n be an ILD String value indicating infinity.\n\t            n = ild.infinity;\n\t            // b. If x < 0, then let negative be true.\n\t            if (x < 0)\n\t                negative = true;\n\t        }\n\t    }\n\t    // 3. Else\n\t    else {\n\t        // a. If x < 0, then\n\t        if (x < 0) {\n\t            // i. Let negative be true.\n\t            negative = true;\n\t            // ii. Let x be -x.\n\t            x = -x;\n\t        }\n\t\n\t        // b. If the value of the [[style]] internal property of numberFormat is\n\t        //    \"percent\", let x be 100  x.\n\t        if (internal['[[style]]'] === 'percent')\n\t            x *= 100;\n\t\n\t        // c. If the [[minimumSignificantDigits]] and [[maximumSignificantDigits]]\n\t        //    internal properties of numberFormat are present, then\n\t        if (hop.call(internal, '[[minimumSignificantDigits]]') &&\n\t                hop.call(internal, '[[maximumSignificantDigits]]'))\n\t            // i. Let n be the result of calling the ToRawPrecision abstract operation\n\t            //    (defined below), passing as arguments x and the values of the\n\t            //    [[minimumSignificantDigits]] and [[maximumSignificantDigits]]\n\t            //    internal properties of numberFormat.\n\t            n = ToRawPrecision(x,\n\t                  internal['[[minimumSignificantDigits]]'],\n\t                  internal['[[maximumSignificantDigits]]']);\n\t        // d. Else\n\t        else\n\t            // i. Let n be the result of calling the ToRawFixed abstract operation\n\t            //    (defined below), passing as arguments x and the values of the\n\t            //    [[minimumIntegerDigits]], [[minimumFractionDigits]], and\n\t            //    [[maximumFractionDigits]] internal properties of numberFormat.\n\t            n = ToRawFixed(x,\n\t                  internal['[[minimumIntegerDigits]]'],\n\t                  internal['[[minimumFractionDigits]]'],\n\t                  internal['[[maximumFractionDigits]]']);\n\t\n\t        // e. If the value of the [[numberingSystem]] internal property of\n\t        //    numberFormat matches one of the values in the Numbering System column\n\t        //    of Table 2 below, then\n\t        if (numSys[nums]) {\n\t            // i. Let digits be an array whose 10 String valued elements are the\n\t            //    UTF-16 string representations of the 10 digits specified in the\n\t            //    Digits column of Table 2 in the row containing the value of the\n\t            //    [[numberingSystem]] internal property.\n\t            var digits = numSys[internal['[[numberingSystem]]']];\n\t            // ii. Replace each digit in n with the value of digits[digit].\n\t            n = String(n).replace(/\\d/g, function (digit) {\n\t                return digits[digit];\n\t            });\n\t        }\n\t        // f. Else use an implementation dependent algorithm to map n to the\n\t        //    appropriate representation of n in the given numbering system.\n\t        else\n\t            n = String(n); // ###TODO###\n\t\n\t        // g. If n contains the character \".\", then replace it with an ILND String\n\t        //    representing the decimal separator.\n\t        n = n.replace(/\\./g, ild.decimal);\n\t\n\t        // h. If the value of the [[useGrouping]] internal property of numberFormat\n\t        //    is true, then insert an ILND String representing a grouping separator\n\t        //    into an ILND set of locations within the integer part of n.\n\t        if (internal['[[useGrouping]]'] === true) {\n\t            var\n\t                parts  = n.split(ild.decimal),\n\t                igr    = parts[0],\n\t\n\t                // Primary group represents the group closest to the decimal\n\t                pgSize = data.patterns.primaryGroupSize || 3,\n\t\n\t                // Secondary group is every other group\n\t                sgSize = data.patterns.secondaryGroupSize || pgSize;\n\t\n\t            // Group only if necessary\n\t            if (igr.length > pgSize) {\n\t                var\n\t                    groups = new List(),\n\t\n\t                    // Index of the primary grouping separator\n\t                    end    = igr.length - pgSize,\n\t\n\t                    // Starting index for our loop\n\t                    idx    = end % sgSize,\n\t\n\t                    start  = igr.slice(0, idx);\n\t\n\t                if (start.length)\n\t                    arrPush.call(groups, start);\n\t\n\t                // Loop to separate into secondary grouping digits\n\t                while (idx < end) {\n\t                    arrPush.call(groups, igr.slice(idx, idx + sgSize));\n\t                    idx += sgSize;\n\t                }\n\t\n\t                // Add the primary grouping digits\n\t                arrPush.call(groups, igr.slice(end));\n\t\n\t                parts[0] = arrJoin.call(groups, ild.group);\n\t            }\n\t\n\t            n = arrJoin.call(parts, ild.decimal);\n\t        }\n\t    }\n\t\n\t    var\n\t    // 4. If negative is true, then let result be the value of the [[negativePattern]]\n\t    //    internal property of numberFormat; else let result be the value of the\n\t    //    [[positivePattern]] internal property of numberFormat.\n\t        result = internal[negative === true ? '[[negativePattern]]' : '[[positivePattern]]'];\n\t\n\t    // 5. Replace the substring \"{number}\" within result with n.\n\t    result = result.replace('{number}', n);\n\t\n\t    // 6. If the value of the [[style]] internal property of numberFormat is\n\t    //    \"currency\", then:\n\t    if (internal['[[style]]'] === 'currency') {\n\t        var cd,\n\t        // a. Let currency be the value of the [[currency]] internal property of\n\t        //    numberFormat.\n\t            currency = internal['[[currency]]'],\n\t\n\t        // Shorthand for the currency data\n\t            cData = data.currencies[currency];\n\t\n\t        // b. If the value of the [[currencyDisplay]] internal property of\n\t        //    numberFormat is \"code\", then let cd be currency.\n\t        // c. Else if the value of the [[currencyDisplay]] internal property of\n\t        //    numberFormat is \"symbol\", then let cd be an ILD string representing\n\t        //    currency in short form. If the implementation does not have such a\n\t        //    representation of currency, then use currency itself.\n\t        // d. Else if the value of the [[currencyDisplay]] internal property of\n\t        //    numberFormat is \"name\", then let cd be an ILD string representing\n\t        //    currency in long form. If the implementation does not have such a\n\t        //    representation of currency, then use currency itself.\n\t        switch (internal['[[currencyDisplay]]']) {\n\t            case 'symbol':\n\t                cd = cData || currency;\n\t                break;\n\t\n\t            default:\n\t            case 'code':\n\t            case 'name':\n\t                cd = currency;\n\t        }\n\t\n\t        // e. Replace the substring \"{currency}\" within result with cd.\n\t        result = result.replace('{currency}', cd);\n\t    }\n\t\n\t    // Restore the RegExp properties\n\t    regexpState.exp.test(regexpState.input);\n\t\n\t    // 7. Return result.\n\t    return result;\n\t}\n\t\n\t/**\n\t * When the ToRawPrecision abstract operation is called with arguments x (which\n\t * must be a finite non-negative number), minPrecision, and maxPrecision (both\n\t * must be integers between 1 and 21) the following steps are taken:\n\t */\n\tfunction ToRawPrecision (x, minPrecision, maxPrecision) {\n\t    var\n\t    // 1. Let p be maxPrecision.\n\t        p = maxPrecision;\n\t\n\t    // 2. If x = 0, then\n\t    if (x === 0) {\n\t        var\n\t        // a. Let m be the String consisting of p occurrences of the character \"0\".\n\t            m = arrJoin.call(Array (p + 1), '0'),\n\t        // b. Let e be 0.\n\t            e = 0;\n\t    }\n\t    // 3. Else\n\t    else {\n\t        // a. Let e and n be integers such that 10  n < 10 and for which the\n\t        //    exact mathematical value of n  10  x is as close to zero as\n\t        //    possible. If there are two such sets of e and n, pick the e and n for\n\t        //    which n  10 is larger.\n\t        var\n\t            e = log10Floor(Math.abs(x)),\n\t\n\t            // Easier to get to m from here\n\t            f = Math.round(Math.exp((Math.abs(e - p + 1)) * Math.LN10)),\n\t\n\t        // b. Let m be the String consisting of the digits of the decimal\n\t        //    representation of n (in order, with no leading zeroes)\n\t            m = String(Math.round(e - p + 1 < 0 ? x * f : x / f));\n\t    }\n\t\n\t    // 4. If e  p, then\n\t    if (e >= p)\n\t        // a. Return the concatenation of m and e-p+1 occurrences of the character \"0\".\n\t        return m + arrJoin.call(Array(e-p+1 + 1), '0');\n\t\n\t    // 5. If e = p-1, then\n\t    else if (e === p - 1)\n\t        // a. Return m.\n\t        return m;\n\t\n\t    // 6. If e  0, then\n\t    else if (e >= 0)\n\t        // a. Let m be the concatenation of the first e+1 characters of m, the character\n\t        //    \".\", and the remaining p(e+1) characters of m.\n\t        m = m.slice(0, e + 1) + '.' + m.slice(e + 1);\n\t\n\t    // 7. If e < 0, then\n\t    else if (e < 0)\n\t        // a. Let m be the concatenation of the String \"0.\", (e+1) occurrences of the\n\t        //    character \"0\", and the string m.\n\t        m = '0.' + arrJoin.call(Array (-(e+1) + 1), '0') + m;\n\t\n\t    // 8. If m contains the character \".\", and maxPrecision > minPrecision, then\n\t    if (m.indexOf(\".\") >= 0 && maxPrecision > minPrecision) {\n\t        var\n\t        // a. Let cut be maxPrecision  minPrecision.\n\t            cut = maxPrecision - minPrecision;\n\t\n\t        // b. Repeat while cut > 0 and the last character of m is \"0\":\n\t        while (cut > 0 && m.charAt(m.length-1) === '0') {\n\t            //  i. Remove the last character from m.\n\t            m = m.slice(0, -1);\n\t\n\t            //  ii. Decrease cut by 1.\n\t            cut--;\n\t        }\n\t\n\t        // c. If the last character of m is \".\", then\n\t        if (m.charAt(m.length-1) === '.')\n\t            //    i. Remove the last character from m.\n\t            m = m.slice(0, -1);\n\t    }\n\t    // 9. Return m.\n\t    return m;\n\t}\n\t\n\t/**\n\t * When the ToRawFixed abstract operation is called with arguments x (which must\n\t * be a finite non-negative number), minInteger (which must be an integer between\n\t * 1 and 21), minFraction, and maxFraction (which must be integers between 0 and\n\t * 20) the following steps are taken:\n\t */\n\tfunction ToRawFixed (x, minInteger, minFraction, maxFraction) {\n\t    // (or not because Number.toPrototype.toFixed does a lot of it for us)\n\t    var idx,\n\t\n\t        // We can pick up after the fixed formatted string (m) is created\n\t        m   = Number.prototype.toFixed.call(x, maxFraction),\n\t\n\t        // 4. If [maxFraction]  0, then\n\t        //    ...\n\t        //    e. Let int be the number of characters in a.\n\t        //\n\t        // 5. Else let int be the number of characters in m.\n\t        igr = m.split(\".\")[0].length,  // int is a reserved word\n\t\n\t        // 6. Let cut be maxFraction  minFraction.\n\t        cut = maxFraction - minFraction,\n\t\n\t        exp = (idx = m.indexOf('e')) > -1 ? m.slice(idx + 1) : 0;\n\t\n\t    if (exp) {\n\t        m = m.slice(0, idx).replace('.', '');\n\t        m += arrJoin.call(Array(exp - (m.length - 1) + 1), '0')\n\t          + '.' + arrJoin.call(Array(maxFraction + 1), '0');\n\t\n\t        igr = m.length;\n\t    }\n\t\n\t    // 7. Repeat while cut > 0 and the last character of m is \"0\":\n\t    while (cut > 0 && m.slice(-1) === \"0\") {\n\t        // a. Remove the last character from m.\n\t        m = m.slice(0, -1);\n\t\n\t        // b. Decrease cut by 1.\n\t        cut--;\n\t    }\n\t\n\t    // 8. If the last character of m is \".\", then\n\t    if (m.slice(-1) === \".\")\n\t        // a. Remove the last character from m.\n\t        m = m.slice(0, -1);\n\t\n\t    // 9. If int < minInteger, then\n\t    if (igr < minInteger)\n\t        // a. Let z be the String consisting of minIntegerint occurrences of the\n\t        //    character \"0\".\n\t        var z = arrJoin.call(Array(minInteger - igr + 1), '0');\n\t\n\t    // 10. Let m be the concatenation of Strings z and m.\n\t    // 11. Return m.\n\t    return (z ? z : '') + m;\n\t}\n\t\n\t// Sect 11.3.2 Table 2, Numbering systems\n\t// ======================================\n\tvar numSys = {\n\t    arab:    [ '\\u0660', '\\u0661', '\\u0662', '\\u0663', '\\u0664', '\\u0665', '\\u0666', '\\u0667', '\\u0668', '\\u0669' ],\n\t    arabext: [ '\\u06F0', '\\u06F1', '\\u06F2', '\\u06F3', '\\u06F4', '\\u06F5', '\\u06F6', '\\u06F7', '\\u06F8', '\\u06F9' ],\n\t    bali:    [ '\\u1B50', '\\u1B51', '\\u1B52', '\\u1B53', '\\u1B54', '\\u1B55', '\\u1B56', '\\u1B57', '\\u1B58', '\\u1B59' ],\n\t    beng:    [ '\\u09E6', '\\u09E7', '\\u09E8', '\\u09E9', '\\u09EA', '\\u09EB', '\\u09EC', '\\u09ED', '\\u09EE', '\\u09EF' ],\n\t    deva:    [ '\\u0966', '\\u0967', '\\u0968', '\\u0969', '\\u096A', '\\u096B', '\\u096C', '\\u096D', '\\u096E', '\\u096F' ],\n\t    fullwide:[ '\\uFF10', '\\uFF11', '\\uFF12', '\\uFF13', '\\uFF14', '\\uFF15', '\\uFF16', '\\uFF17', '\\uFF18', '\\uFF19' ],\n\t    gujr:    [ '\\u0AE6', '\\u0AE7', '\\u0AE8', '\\u0AE9', '\\u0AEA', '\\u0AEB', '\\u0AEC', '\\u0AED', '\\u0AEE', '\\u0AEF' ],\n\t    guru:    [ '\\u0A66', '\\u0A67', '\\u0A68', '\\u0A69', '\\u0A6A', '\\u0A6B', '\\u0A6C', '\\u0A6D', '\\u0A6E', '\\u0A6F' ],\n\t    hanidec: [ '\\u3007', '\\u4E00', '\\u4E8C', '\\u4E09', '\\u56DB', '\\u4E94', '\\u516D', '\\u4E03', '\\u516B', '\\u4E5D' ],\n\t    khmr:    [ '\\u17E0', '\\u17E1', '\\u17E2', '\\u17E3', '\\u17E4', '\\u17E5', '\\u17E6', '\\u17E7', '\\u17E8', '\\u17E9' ],\n\t    knda:    [ '\\u0CE6', '\\u0CE7', '\\u0CE8', '\\u0CE9', '\\u0CEA', '\\u0CEB', '\\u0CEC', '\\u0CED', '\\u0CEE', '\\u0CEF' ],\n\t    laoo:    [ '\\u0ED0', '\\u0ED1', '\\u0ED2', '\\u0ED3', '\\u0ED4', '\\u0ED5', '\\u0ED6', '\\u0ED7', '\\u0ED8', '\\u0ED9' ],\n\t    latn:    [ '\\u0030', '\\u0031', '\\u0032', '\\u0033', '\\u0034', '\\u0035', '\\u0036', '\\u0037', '\\u0038', '\\u0039' ],\n\t    limb:    [ '\\u1946', '\\u1947', '\\u1948', '\\u1949', '\\u194A', '\\u194B', '\\u194C', '\\u194D', '\\u194E', '\\u194F' ],\n\t    mlym:    [ '\\u0D66', '\\u0D67', '\\u0D68', '\\u0D69', '\\u0D6A', '\\u0D6B', '\\u0D6C', '\\u0D6D', '\\u0D6E', '\\u0D6F' ],\n\t    mong:    [ '\\u1810', '\\u1811', '\\u1812', '\\u1813', '\\u1814', '\\u1815', '\\u1816', '\\u1817', '\\u1818', '\\u1819' ],\n\t    mymr:    [ '\\u1040', '\\u1041', '\\u1042', '\\u1043', '\\u1044', '\\u1045', '\\u1046', '\\u1047', '\\u1048', '\\u1049' ],\n\t    orya:    [ '\\u0B66', '\\u0B67', '\\u0B68', '\\u0B69', '\\u0B6A', '\\u0B6B', '\\u0B6C', '\\u0B6D', '\\u0B6E', '\\u0B6F' ],\n\t    tamldec: [ '\\u0BE6', '\\u0BE7', '\\u0BE8', '\\u0BE9', '\\u0BEA', '\\u0BEB', '\\u0BEC', '\\u0BED', '\\u0BEE', '\\u0BEF' ],\n\t    telu:    [ '\\u0C66', '\\u0C67', '\\u0C68', '\\u0C69', '\\u0C6A', '\\u0C6B', '\\u0C6C', '\\u0C6D', '\\u0C6E', '\\u0C6F' ],\n\t    thai:    [ '\\u0E50', '\\u0E51', '\\u0E52', '\\u0E53', '\\u0E54', '\\u0E55', '\\u0E56', '\\u0E57', '\\u0E58', '\\u0E59' ],\n\t    tibt:    [ '\\u0F20', '\\u0F21', '\\u0F22', '\\u0F23', '\\u0F24', '\\u0F25', '\\u0F26', '\\u0F27', '\\u0F28', '\\u0F29' ]\n\t};\n\t\n\t/**\n\t * This function provides access to the locale and formatting options computed\n\t * during initialization of the object.\n\t *\n\t * The function returns a new object whose properties and attributes are set as\n\t * if constructed by an object literal assigning to each of the following\n\t * properties the value of the corresponding internal property of this\n\t * NumberFormat object (see 11.4): locale, numberingSystem, style, currency,\n\t * currencyDisplay, minimumIntegerDigits, minimumFractionDigits,\n\t * maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, and\n\t * useGrouping. Properties whose corresponding internal properties are not present\n\t * are not assigned.\n\t */\n\t/* 11.3.3 */defineProperty(Intl.NumberFormat.prototype, 'resolvedOptions', {\n\t    configurable: true,\n\t    writable: true,\n\t    value: function () {\n\t        var prop,\n\t            descs = new Record(),\n\t            props = [\n\t                'locale', 'numberingSystem', 'style', 'currency', 'currencyDisplay',\n\t                'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits',\n\t                'minimumSignificantDigits', 'maximumSignificantDigits', 'useGrouping'\n\t            ],\n\t            internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\t\n\t        // Satisfy test 11.3_b\n\t        if (!internal || !internal['[[initializedNumberFormat]]'])\n\t            throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.NumberFormat object.');\n\t\n\t        for (var i = 0, max = props.length; i < max; i++) {\n\t            if (hop.call(internal, prop = '[['+ props[i] +']]'))\n\t                descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n\t        }\n\t\n\t        return objCreate({}, descs);\n\t    }\n\t});\n\t\n\t// 12.1 The Intl.DateTimeFormat constructor\n\t// ==================================\n\t\n\t// Define the DateTimeFormat constructor internally so it cannot be tainted\n\tfunction DateTimeFormatConstructor () {\n\t    var locales = arguments[0];\n\t    var options = arguments[1];\n\t\n\t    if (!this || this === Intl) {\n\t        return new Intl.DateTimeFormat(locales, options);\n\t    }\n\t    return InitializeDateTimeFormat(toObject(this), locales, options);\n\t}\n\t\n\tdefineProperty(Intl, 'DateTimeFormat', {\n\t    configurable: true,\n\t    writable: true,\n\t    value: DateTimeFormatConstructor\n\t});\n\t\n\t// Must explicitly set prototypes as unwritable\n\tdefineProperty(DateTimeFormatConstructor, 'prototype', {\n\t    writable: false\n\t});\n\t\n\t/**\n\t * The abstract operation InitializeDateTimeFormat accepts the arguments dateTimeFormat\n\t * (which must be an object), locales, and options. It initializes dateTimeFormat as a\n\t * DateTimeFormat object.\n\t */\n\tfunction/* 12.1.1.1 */InitializeDateTimeFormat (dateTimeFormat, locales, options) {\n\t    var\n\t    // This will be a internal properties object if we're not already initialized\n\t        internal = getInternalProperties(dateTimeFormat),\n\t\n\t    // Create an object whose props can be used to restore the values of RegExp props\n\t        regexpState = createRegExpRestore();\n\t\n\t    // 1. If dateTimeFormat has an [[initializedIntlObject]] internal property with\n\t    //    value true, throw a TypeError exception.\n\t    if (internal['[[initializedIntlObject]]'] === true)\n\t        throw new TypeError('`this` object has already been initialized as an Intl object');\n\t\n\t    // Need this to access the `internal` object\n\t    defineProperty(dateTimeFormat, '__getInternalProperties', {\n\t        value: function () {\n\t            // NOTE: Non-standard, for internal use only\n\t            if (arguments[0] === secret)\n\t                return internal;\n\t        }\n\t    });\n\t\n\t    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n\t    internal['[[initializedIntlObject]]'] = true;\n\t\n\t    var\n\t    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n\t    //    abstract operation (defined in 9.2.1) with argument locales.\n\t        requestedLocales = CanonicalizeLocaleList(locales),\n\t\n\t    // 4. Let options be the result of calling the ToDateTimeOptions abstract\n\t    //    operation (defined below) with arguments options, \"any\", and \"date\".\n\t        options = ToDateTimeOptions(options, 'any', 'date'),\n\t\n\t    // 5. Let opt be a new Record.\n\t        opt = new Record();\n\t\n\t    // 6. Let matcher be the result of calling the GetOption abstract operation\n\t    //    (defined in 9.2.9) with arguments options, \"localeMatcher\", \"string\", a List\n\t    //    containing the two String values \"lookup\" and \"best fit\", and \"best fit\".\n\t        matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\t\n\t    // 7. Set opt.[[localeMatcher]] to matcher.\n\t    opt['[[localeMatcher]]'] = matcher;\n\t\n\t    var\n\t    // 8. Let DateTimeFormat be the standard built-in object that is the initial\n\t    //    value of Intl.DateTimeFormat.\n\t        DateTimeFormat = internals.DateTimeFormat, // This is what we *really* need\n\t\n\t    // 9. Let localeData be the value of the [[localeData]] internal property of\n\t    //    DateTimeFormat.\n\t        localeData = DateTimeFormat['[[localeData]]'],\n\t\n\t    // 10. Let r be the result of calling the ResolveLocale abstract operation\n\t    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n\t    //      DateTimeFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n\t    //      internal property of DateTimeFormat, and localeData.\n\t        r = ResolveLocale(DateTimeFormat['[[availableLocales]]'], requestedLocales,\n\t                opt, DateTimeFormat['[[relevantExtensionKeys]]'], localeData);\n\t\n\t    // 11. Set the [[locale]] internal property of dateTimeFormat to the value of\n\t    //     r.[[locale]].\n\t    internal['[[locale]]'] = r['[[locale]]'];\n\t\n\t    // 12. Set the [[calendar]] internal property of dateTimeFormat to the value of\n\t    //     r.[[ca]].\n\t    internal['[[calendar]]'] = r['[[ca]]'];\n\t\n\t    // 13. Set the [[numberingSystem]] internal property of dateTimeFormat to the value of\n\t    //     r.[[nu]].\n\t    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\t\n\t    // The specification doesn't tell us to do this, but it's helpful later on\n\t    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\t\n\t    var\n\t    // 14. Let dataLocale be the value of r.[[dataLocale]].\n\t        dataLocale = r['[[dataLocale]]'],\n\t\n\t    // 15. Let tz be the result of calling the [[Get]] internal method of options with\n\t    //     argument \"timeZone\".\n\t        tz = options.timeZone;\n\t\n\t    // 16. If tz is not undefined, then\n\t    if (tz !== undefined) {\n\t        // a. Let tz be ToString(tz).\n\t        // b. Convert tz to upper case as described in 6.1.\n\t        //    NOTE: If an implementation accepts additional time zone values, as permitted\n\t        //          under certain conditions by the Conformance clause, different casing\n\t        //          rules apply.\n\t        tz = toLatinUpperCase(tz);\n\t\n\t        // c. If tz is not \"UTC\", then throw a RangeError exception.\n\t        // ###TODO: accept more time zones###\n\t        if (tz !== 'UTC')\n\t            throw new RangeError('timeZone is not supported.');\n\t    }\n\t\n\t    // 17. Set the [[timeZone]] internal property of dateTimeFormat to tz.\n\t    internal['[[timeZone]]'] = tz;\n\t\n\t    // 18. Let opt be a new Record.\n\t    opt = new Record();\n\t\n\t    // 19. For each row of Table 3, except the header row, do:\n\t    for (var prop in dateTimeComponents) {\n\t        if (!hop.call(dateTimeComponents, prop))\n\t            continue;\n\t\n\t        var\n\t        // 20. Let prop be the name given in the Property column of the row.\n\t        // 21. Let value be the result of calling the GetOption abstract operation,\n\t        //     passing as argument options, the name given in the Property column of the\n\t        //     row, \"string\", a List containing the strings given in the Values column of\n\t        //     the row, and undefined.\n\t            value = GetOption(options, prop, 'string', dateTimeComponents[prop]);\n\t\n\t        // 22. Set opt.[[<prop>]] to value.\n\t        opt['[['+prop+']]'] = value;\n\t    }\n\t\n\t    var\n\t        // Assigned a value below\n\t        bestFormat,\n\t\n\t        // 23. Let dataLocaleData be the result of calling the [[Get]] internal method of\n\t        //     localeData with argument dataLocale.\n\t        dataLocaleData = localeData[dataLocale],\n\t\n\t        // 24. Let formats be the result of calling the [[Get]] internal method of\n\t        //     dataLocaleData with argument \"formats\".\n\t        //     Note: we process the CLDR formats into the spec'd structure\n\t        formats = ToDateTimeFormats(dataLocaleData.formats),\n\t\n\t        // 25. Let matcher be the result of calling the GetOption abstract operation with\n\t        //     arguments options, \"formatMatcher\", \"string\", a List containing the two String\n\t        //     values \"basic\" and \"best fit\", and \"best fit\".\n\t        matcher = GetOption(options, 'formatMatcher', 'string', new List('basic', 'best fit'), 'best fit');\n\t\n\t    // Optimization: caching the processed formats as a one time operation by\n\t    // replacing the initial structure from localeData\n\t    dataLocaleData.formats = formats;\n\t\n\t    // 26. If matcher is \"basic\", then\n\t    if (matcher === 'basic')\n\t        // 27. Let bestFormat be the result of calling the BasicFormatMatcher abstract\n\t        //     operation (defined below) with opt and formats.\n\t        bestFormat = BasicFormatMatcher(opt, formats);\n\t\n\t    // 28. Else\n\t    else\n\t        // 29. Let bestFormat be the result of calling the BestFitFormatMatcher\n\t        //     abstract operation (defined below) with opt and formats.\n\t        bestFormat = BestFitFormatMatcher(opt, formats);\n\t\n\t    // 30. For each row in Table 3, except the header row, do\n\t    for (var prop in dateTimeComponents) {\n\t        if (!hop.call(dateTimeComponents, prop))\n\t            continue;\n\t\n\t        // a. Let prop be the name given in the Property column of the row.\n\t        // b. Let pDesc be the result of calling the [[GetOwnProperty]] internal method of\n\t        //    bestFormat with argument prop.\n\t        // c. If pDesc is not undefined, then\n\t        if (hop.call(bestFormat, prop)) {\n\t            var\n\t            // i. Let p be the result of calling the [[Get]] internal method of bestFormat\n\t            //    with argument prop.\n\t                p = bestFormat[prop];\n\t\n\t            // ii. Set the [[<prop>]] internal property of dateTimeFormat to p.\n\t            internal['[['+prop+']]'] = p;\n\t        }\n\t    }\n\t\n\t    var\n\t        // Assigned a value below\n\t        pattern,\n\t\n\t    // 31. Let hr12 be the result of calling the GetOption abstract operation with\n\t    //     arguments options, \"hour12\", \"boolean\", undefined, and undefined.\n\t        hr12 = GetOption(options, 'hour12', 'boolean'/*, undefined, undefined*/);\n\t\n\t    // 32. If dateTimeFormat has an internal property [[hour]], then\n\t    if (internal['[[hour]]']) {\n\t        // a. If hr12 is undefined, then let hr12 be the result of calling the [[Get]]\n\t        //    internal method of dataLocaleData with argument \"hour12\".\n\t        hr12 = hr12 === undefined ? dataLocaleData.hour12 : hr12;\n\t\n\t        // b. Set the [[hour12]] internal property of dateTimeFormat to hr12.\n\t        internal['[[hour12]]'] = hr12;\n\t\n\t        // c. If hr12 is true, then\n\t        if (hr12 === true) {\n\t            var\n\t            // i. Let hourNo0 be the result of calling the [[Get]] internal method of\n\t            //    dataLocaleData with argument \"hourNo0\".\n\t                hourNo0 = dataLocaleData.hourNo0;\n\t\n\t            // ii. Set the [[hourNo0]] internal property of dateTimeFormat to hourNo0.\n\t            internal['[[hourNo0]]'] = hourNo0;\n\t\n\t            // iii. Let pattern be the result of calling the [[Get]] internal method of\n\t            //      bestFormat with argument \"pattern12\".\n\t            pattern = bestFormat.pattern12;\n\t        }\n\t\n\t        // d. Else\n\t        else\n\t            // i. Let pattern be the result of calling the [[Get]] internal method of\n\t            //    bestFormat with argument \"pattern\".\n\t            pattern = bestFormat.pattern;\n\t    }\n\t\n\t    // 33. Else\n\t    else\n\t        // a. Let pattern be the result of calling the [[Get]] internal method of\n\t        //    bestFormat with argument \"pattern\".\n\t        pattern = bestFormat.pattern;\n\t\n\t    // 34. Set the [[pattern]] internal property of dateTimeFormat to pattern.\n\t    internal['[[pattern]]'] = pattern;\n\t\n\t    // 35. Set the [[boundFormat]] internal property of dateTimeFormat to undefined.\n\t    internal['[[boundFormat]]'] = undefined;\n\t\n\t    // 36. Set the [[initializedDateTimeFormat]] internal property of dateTimeFormat to\n\t    //     true.\n\t    internal['[[initializedDateTimeFormat]]'] = true;\n\t\n\t    // In ES3, we need to pre-bind the format() function\n\t    if (es3)\n\t        dateTimeFormat.format = GetFormatDateTime.call(dateTimeFormat);\n\t\n\t    // Restore the RegExp properties\n\t    regexpState.exp.test(regexpState.input);\n\t\n\t    // Return the newly initialised object\n\t    return dateTimeFormat;\n\t}\n\t\n\t/**\n\t * Several DateTimeFormat algorithms use values from the following table, which provides\n\t * property names and allowable values for the components of date and time formats:\n\t */\n\tvar dateTimeComponents = {\n\t         weekday: [ \"narrow\", \"short\", \"long\" ],\n\t             era: [ \"narrow\", \"short\", \"long\" ],\n\t            year: [ \"2-digit\", \"numeric\" ],\n\t           month: [ \"2-digit\", \"numeric\", \"narrow\", \"short\", \"long\" ],\n\t             day: [ \"2-digit\", \"numeric\" ],\n\t            hour: [ \"2-digit\", \"numeric\" ],\n\t          minute: [ \"2-digit\", \"numeric\" ],\n\t          second: [ \"2-digit\", \"numeric\" ],\n\t    timeZoneName: [ \"short\", \"long\" ]\n\t};\n\t\n\t/**\n\t * When the ToDateTimeOptions abstract operation is called with arguments options,\n\t * required, and defaults, the following steps are taken:\n\t */\n\tfunction ToDateTimeFormats(formats) {\n\t    if (Object.prototype.toString.call(formats) === '[object Array]') {\n\t        return formats;\n\t    }\n\t    return src$cldr$$.createDateTimeFormats(formats);\n\t}\n\t\n\t/**\n\t * When the ToDateTimeOptions abstract operation is called with arguments options,\n\t * required, and defaults, the following steps are taken:\n\t */\n\tfunction ToDateTimeOptions (options, required, defaults) {\n\t    // 1. If options is undefined, then let options be null, else let options be\n\t    //    ToObject(options).\n\t    if (options === undefined)\n\t        options = null;\n\t\n\t    else {\n\t        // (#12) options needs to be a Record, but it also needs to inherit properties\n\t        var opt2 = toObject(options);\n\t        options = new Record();\n\t\n\t        for (var k in opt2)\n\t            options[k] = opt2[k];\n\t    }\n\t\n\t    var\n\t    // 2. Let create be the standard built-in function object defined in ES5, 15.2.3.5.\n\t        create = objCreate,\n\t\n\t    // 3. Let options be the result of calling the [[Call]] internal method of create with\n\t    //    undefined as the this value and an argument list containing the single item\n\t    //    options.\n\t        options = create(options),\n\t\n\t    // 4. Let needDefaults be true.\n\t        needDefaults = true;\n\t\n\t    // 5. If required is \"date\" or \"any\", then\n\t    if (required === 'date' || required === 'any') {\n\t        // a. For each of the property names \"weekday\", \"year\", \"month\", \"day\":\n\t            // i. If the result of calling the [[Get]] internal method of options with the\n\t            //    property name is not undefined, then let needDefaults be false.\n\t        if (options.weekday !== undefined || options.year !== undefined\n\t                || options.month !== undefined || options.day !== undefined)\n\t            needDefaults = false;\n\t    }\n\t\n\t    // 6. If required is \"time\" or \"any\", then\n\t    if (required === 'time' || required === 'any') {\n\t        // a. For each of the property names \"hour\", \"minute\", \"second\":\n\t            // i. If the result of calling the [[Get]] internal method of options with the\n\t            //    property name is not undefined, then let needDefaults be false.\n\t        if (options.hour !== undefined || options.minute !== undefined || options.second !== undefined)\n\t                needDefaults = false;\n\t    }\n\t\n\t    // 7. If needDefaults is true and defaults is either \"date\" or \"all\", then\n\t    if (needDefaults && (defaults === 'date' || defaults === 'all'))\n\t        // a. For each of the property names \"year\", \"month\", \"day\":\n\t            // i. Call the [[DefineOwnProperty]] internal method of options with the\n\t            //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n\t            //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n\t        options.year = options.month = options.day = 'numeric';\n\t\n\t    // 8. If needDefaults is true and defaults is either \"time\" or \"all\", then\n\t    if (needDefaults && (defaults === 'time' || defaults === 'all'))\n\t        // a. For each of the property names \"hour\", \"minute\", \"second\":\n\t            // i. Call the [[DefineOwnProperty]] internal method of options with the\n\t            //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n\t            //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n\t        options.hour = options.minute = options.second = 'numeric';\n\t\n\t    // 9. Return options.\n\t    return options;\n\t}\n\t\n\t/**\n\t * When the BasicFormatMatcher abstract operation is called with two arguments options and\n\t * formats, the following steps are taken:\n\t */\n\tfunction BasicFormatMatcher (options, formats) {\n\t    return calculateScore(options, formats);\n\t}\n\t\n\t/**\n\t * Calculates score for BestFitFormatMatcher and BasicFormatMatcher.\n\t * Abstracted from BasicFormatMatcher section.\n\t */\n\tfunction calculateScore (options, formats, bestFit) {\n\t    var\n\t    // Additional penalty type when bestFit === true\n\t       diffDataTypePenalty = 8,\n\t\n\t    // 1. Let removalPenalty be 120.\n\t        removalPenalty = 120,\n\t\n\t    // 2. Let additionPenalty be 20.\n\t        additionPenalty = 20,\n\t\n\t    // 3. Let longLessPenalty be 8.\n\t        longLessPenalty = 8,\n\t\n\t    // 4. Let longMorePenalty be 6.\n\t        longMorePenalty = 6,\n\t\n\t    // 5. Let shortLessPenalty be 6.\n\t        shortLessPenalty = 6,\n\t\n\t    // 6. Let shortMorePenalty be 3.\n\t        shortMorePenalty = 3,\n\t\n\t    // 7. Let bestScore be -Infinity.\n\t        bestScore = -Infinity,\n\t\n\t    // 8. Let bestFormat be undefined.\n\t        bestFormat,\n\t\n\t    // 9. Let i be 0.\n\t        i = 0,\n\t\n\t    // 10. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n\t        len = formats.length;\n\t\n\t    // 11. Repeat while i < len:\n\t    while (i < len) {\n\t        var\n\t        // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n\t            format = formats[i],\n\t\n\t        // b. Let score be 0.\n\t            score = 0;\n\t\n\t        // c. For each property shown in Table 3:\n\t        for (var property in dateTimeComponents) {\n\t            if (!hop.call(dateTimeComponents, property))\n\t                continue;\n\t\n\t            var\n\t            // i. Let optionsProp be options.[[<property>]].\n\t                optionsProp = options['[['+ property +']]'],\n\t\n\t            // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n\t            //     with argument property.\n\t            // iii. If formatPropDesc is not undefined, then\n\t            //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n\t                formatProp = hop.call(format, property) ? format[property] : undefined;\n\t\n\t            // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n\t            //     additionPenalty.\n\t            if (optionsProp === undefined && formatProp !== undefined)\n\t                score -= additionPenalty;\n\t\n\t            // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n\t            //    removalPenalty.\n\t            else if (optionsProp !== undefined && formatProp === undefined)\n\t                score -= removalPenalty;\n\t\n\t            // vi. Else\n\t            else {\n\t                var\n\t                // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n\t                //    \"long\"].\n\t                    values = [ '2-digit', 'numeric', 'narrow', 'short', 'long' ],\n\t\n\t                // 2. Let optionsPropIndex be the index of optionsProp within values.\n\t                    optionsPropIndex = arrIndexOf.call(values, optionsProp),\n\t\n\t                // 3. Let formatPropIndex be the index of formatProp within values.\n\t                    formatPropIndex = arrIndexOf.call(values, formatProp),\n\t\n\t                // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n\t                    delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n\t\n\t                // When the bestFit argument is true, subtract additional penalty where data types are not the same\n\t                if (bestFit && (\n\t                    ((optionsProp === 'numeric' || optionsProp === '2-digit') && (formatProp !== 'numeric' && formatProp !== '2-digit') || (optionsProp !== 'numeric' && optionsProp !== '2-digit') && (formatProp === '2-digit' || formatProp === 'numeric'))\n\t                ))\n\t                    score -= diffDataTypePenalty;\n\t\n\t                // 5. If delta = 2, decrease score by longMorePenalty.\n\t                if (delta === 2)\n\t                    score -= longMorePenalty;\n\t\n\t                // 6. Else if delta = 1, decrease score by shortMorePenalty.\n\t                else if (delta === 1)\n\t                    score -= shortMorePenalty;\n\t\n\t                // 7. Else if delta = -1, decrease score by shortLessPenalty.\n\t                else if (delta === -1)\n\t                    score -= shortLessPenalty;\n\t\n\t                // 8. Else if delta = -2, decrease score by longLessPenalty.\n\t                else if (delta === -2)\n\t                    score -= longLessPenalty;\n\t            }\n\t        }\n\t\n\t        // d. If score > bestScore, then\n\t        if (score > bestScore) {\n\t            // i. Let bestScore be score.\n\t            bestScore = score;\n\t\n\t            // ii. Let bestFormat be format.\n\t            bestFormat = format;\n\t        }\n\t\n\t        // e. Increase i by 1.\n\t        i++;\n\t    }\n\t\n\t    // 12. Return bestFormat.\n\t    return bestFormat;\n\t}\n\t\n\t/**\n\t * When the BestFitFormatMatcher abstract operation is called with two arguments options\n\t * and formats, it performs implementation dependent steps, which should return a set of\n\t * component representations that a typical user of the selected locale would perceive as\n\t * at least as good as the one returned by BasicFormatMatcher.\n\t *\n\t * This polyfill defines the algorithm to be the same as BasicFormatMatcher,\n\t * with the addition of bonus points awarded where the requested format is of\n\t * the same data type as the potentially matching format.\n\t *\n\t * For example,\n\t *\n\t *     { month: 'numeric', day: 'numeric' }\n\t *\n\t * should match\n\t *\n\t *     { month: '2-digit', day: '2-digit' }\n\t *\n\t * rather than\n\t *\n\t *     { month: 'short', day: 'numeric' }\n\t *\n\t * This makes sense because a user requesting a formatted date with numeric parts would\n\t * not expect to see the returned format containing narrow, short or long part names\n\t */\n\tfunction BestFitFormatMatcher (options, formats) {\n\t    return calculateScore(options, formats, true);\n\t}\n\t\n\t/* 12.2.3 */internals.DateTimeFormat = {\n\t    '[[availableLocales]]': [],\n\t    '[[relevantExtensionKeys]]': ['ca', 'nu'],\n\t    '[[localeData]]': {}\n\t};\n\t\n\t/**\n\t * When the supportedLocalesOf method of Intl.DateTimeFormat is called, the\n\t * following steps are taken:\n\t */\n\t/* 12.2.2 */defineProperty(Intl.DateTimeFormat, 'supportedLocalesOf', {\n\t    configurable: true,\n\t    writable: true,\n\t    value: fnBind.call(supportedLocalesOf, internals.DateTimeFormat)\n\t});\n\t\n\t/**\n\t * This named accessor property returns a function that formats a number\n\t * according to the effective locale and the formatting options of this\n\t * DateTimeFormat object.\n\t */\n\t/* 12.3.2 */defineProperty(Intl.DateTimeFormat.prototype, 'format', {\n\t    configurable: true,\n\t    get: GetFormatDateTime\n\t});\n\t\n\tfunction GetFormatDateTime() {\n\t    var internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\t\n\t    // Satisfy test 12.3_b\n\t    if (!internal || !internal['[[initializedDateTimeFormat]]'])\n\t        throw new TypeError('`this` value for format() is not an initialized Intl.DateTimeFormat object.');\n\t\n\t    // The value of the [[Get]] attribute is a function that takes the following\n\t    // steps:\n\t\n\t    // 1. If the [[boundFormat]] internal property of this DateTimeFormat object\n\t    //    is undefined, then:\n\t    if (internal['[[boundFormat]]'] === undefined) {\n\t        var\n\t        // a. Let F be a Function object, with internal properties set as\n\t        //    specified for built-in functions in ES5, 15, or successor, and the\n\t        //    length property set to 0, that takes the argument date and\n\t        //    performs the following steps:\n\t            F = function () {\n\t                //   i. If date is not provided or is undefined, then let x be the\n\t                //      result as if by the expression Date.now() where Date.now is\n\t                //      the standard built-in function defined in ES5, 15.9.4.4.\n\t                //  ii. Else let x be ToNumber(date).\n\t                // iii. Return the result of calling the FormatDateTime abstract\n\t                //      operation (defined below) with arguments this and x.\n\t                var x = Number(arguments.length === 0 ? Date.now() : arguments[0]);\n\t                return FormatDateTime(this, x);\n\t            },\n\t        // b. Let bind be the standard built-in function object defined in ES5,\n\t        //    15.3.4.5.\n\t        // c. Let bf be the result of calling the [[Call]] internal method of\n\t        //    bind with F as the this value and an argument list containing\n\t        //    the single item this.\n\t            bf = fnBind.call(F, this);\n\t        // d. Set the [[boundFormat]] internal property of this NumberFormat\n\t        //    object to bf.\n\t        internal['[[boundFormat]]'] = bf;\n\t    }\n\t    // Return the value of the [[boundFormat]] internal property of this\n\t    // NumberFormat object.\n\t    return internal['[[boundFormat]]'];\n\t}\n\t\n\t/**\n\t * When the FormatDateTime abstract operation is called with arguments dateTimeFormat\n\t * (which must be an object initialized as a DateTimeFormat) and x (which must be a Number\n\t * value), it returns a String value representing x (interpreted as a time value as\n\t * specified in ES5, 15.9.1.1) according to the effective locale and the formatting\n\t * options of dateTimeFormat.\n\t */\n\tfunction FormatDateTime(dateTimeFormat, x) {\n\t    // 1. If x is not a finite Number, then throw a RangeError exception.\n\t    if (!isFinite(x))\n\t        throw new RangeError('Invalid valid date passed to format');\n\t\n\t    var\n\t        internal = dateTimeFormat.__getInternalProperties(secret),\n\t\n\t    // Creating restore point for properties on the RegExp object... please wait\n\t        regexpState = createRegExpRestore(),\n\t\n\t    // 2. Let locale be the value of the [[locale]] internal property of dateTimeFormat.\n\t        locale = internal['[[locale]]'],\n\t\n\t    // 3. Let nf be the result of creating a new NumberFormat object as if by the\n\t    // expression new Intl.NumberFormat([locale], {useGrouping: false}) where\n\t    // Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n\t        nf = new Intl.NumberFormat([locale], {useGrouping: false}),\n\t\n\t    // 4. Let nf2 be the result of creating a new NumberFormat object as if by the\n\t    // expression new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping:\n\t    // false}) where Intl.NumberFormat is the standard built-in constructor defined in\n\t    // 11.1.3.\n\t        nf2 = new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping: false}),\n\t\n\t    // 5. Let tm be the result of calling the ToLocalTime abstract operation (defined\n\t    // below) with x, the value of the [[calendar]] internal property of dateTimeFormat,\n\t    // and the value of the [[timeZone]] internal property of dateTimeFormat.\n\t        tm = ToLocalTime(x, internal['[[calendar]]'], internal['[[timeZone]]']),\n\t\n\t    // 6. Let result be the value of the [[pattern]] internal property of dateTimeFormat.\n\t        result = internal['[[pattern]]'],\n\t\n\t    // Need the locale minus any extensions\n\t        dataLocale = internal['[[dataLocale]]'],\n\t\n\t    // Need the calendar data from CLDR\n\t        localeData = internals.DateTimeFormat['[[localeData]]'][dataLocale].calendars,\n\t        ca = internal['[[calendar]]'];\n\t\n\t    // 7. For each row of Table 3, except the header row, do:\n\t    for (var p in dateTimeComponents) {\n\t        // a. If dateTimeFormat has an internal property with the name given in the\n\t        //    Property column of the row, then:\n\t        if (hop.call(internal, '[['+ p +']]')) {\n\t            var\n\t            // Assigned values below\n\t                pm, fv,\n\t\n\t            //   i. Let p be the name given in the Property column of the row.\n\t            //  ii. Let f be the value of the [[<p>]] internal property of dateTimeFormat.\n\t                f = internal['[['+ p +']]'],\n\t\n\t            // iii. Let v be the value of tm.[[<p>]].\n\t                v = tm['[['+ p +']]'];\n\t\n\t            //  iv. If p is \"year\" and v  0, then let v be 1 - v.\n\t            if (p === 'year' && v <= 0)\n\t                v = 1 - v;\n\t\n\t            //   v. If p is \"month\", then increase v by 1.\n\t            else if (p === 'month')\n\t                v++;\n\t\n\t            //  vi. If p is \"hour\" and the value of the [[hour12]] internal property of\n\t            //      dateTimeFormat is true, then\n\t            else if (p === 'hour' && internal['[[hour12]]'] === true) {\n\t                // 1. Let v be v modulo 12.\n\t                v = v % 12;\n\t\n\t                // 2. If v is equal to the value of tm.[[<p>]], then let pm be false; else\n\t                //    let pm be true.\n\t                pm = v !== tm['[['+ p +']]'];\n\t\n\t                // 3. If v is 0 and the value of the [[hourNo0]] internal property of\n\t                //    dateTimeFormat is true, then let v be 12.\n\t                if (v === 0 && internal['[[hourNo0]]'] === true)\n\t                    v = 12;\n\t            }\n\t\n\t            // vii. If f is \"numeric\", then\n\t            if (f === 'numeric')\n\t                // 1. Let fv be the result of calling the FormatNumber abstract operation\n\t                //    (defined in 11.3.2) with arguments nf and v.\n\t                fv = FormatNumber(nf, v);\n\t\n\t            // viii. Else if f is \"2-digit\", then\n\t            else if (f === '2-digit') {\n\t                // 1. Let fv be the result of calling the FormatNumber abstract operation\n\t                //    with arguments nf2 and v.\n\t                fv = FormatNumber(nf2, v);\n\t\n\t                // 2. If the length of fv is greater than 2, let fv be the substring of fv\n\t                //    containing the last two characters.\n\t                if (fv.length > 2)\n\t                    fv = fv.slice(-2);\n\t            }\n\t\n\t            // ix. Else if f is \"narrow\", \"short\", or \"long\", then let fv be a String\n\t            //     value representing f in the desired form; the String value depends upon\n\t            //     the implementation and the effective locale and calendar of\n\t            //     dateTimeFormat. If p is \"month\", then the String value may also depend\n\t            //     on whether dateTimeFormat has a [[day]] internal property. If p is\n\t            //     \"timeZoneName\", then the String value may also depend on the value of\n\t            //     the [[inDST]] field of tm.\n\t            else if (f in dateWidths) {\n\t                switch (p) {\n\t                    case 'month':\n\t                        fv = resolveDateString(localeData, ca, 'months', f, tm['[['+ p +']]']);\n\t                        break;\n\t\n\t                    case 'weekday':\n\t                        try {\n\t                            fv = resolveDateString(localeData, ca, 'days', f, tm['[['+ p +']]']);\n\t                            // fv = resolveDateString(ca.days, f)[tm['[['+ p +']]']];\n\t                        } catch (e) {\n\t                            throw new Error('Could not find weekday data for locale '+locale);\n\t                        }\n\t                        break;\n\t\n\t                    case 'timeZoneName':\n\t                        fv = ''; // TODO\n\t                        break;\n\t\n\t                    // TODO: Era\n\t                    default:\n\t                        fv = tm['[['+ p +']]'];\n\t                }\n\t            }\n\t\n\t            // x. Replace the substring of result that consists of \"{\", p, and \"}\", with\n\t            //    fv.\n\t            result = result.replace('{'+ p +'}', fv);\n\t        }\n\t    }\n\t    // 8. If dateTimeFormat has an internal property [[hour12]] whose value is true, then\n\t    if (internal['[[hour12]]'] === true) {\n\t        // a. If pm is true, then let fv be an implementation and locale dependent String\n\t        //    value representing post meridiem; else let fv be an implementation and\n\t        //    locale dependent String value representing ante meridiem.\n\t        fv = resolveDateString(localeData, ca, 'dayPeriods', pm ? 'pm' : 'am');\n\t\n\t        // b. Replace the substring of result that consists of \"{ampm}\", with fv.\n\t        result = result.replace('{ampm}', fv);\n\t    }\n\t\n\t    // Restore properties of the RegExp object\n\t    regexpState.exp.test(regexpState.input);\n\t\n\t    // 9. Return result.\n\t    return result;\n\t}\n\t\n\t/**\n\t * When the ToLocalTime abstract operation is called with arguments date, calendar, and\n\t * timeZone, the following steps are taken:\n\t */\n\tfunction ToLocalTime(date, calendar, timeZone) {\n\t    // 1. Apply calendrical calculations on date for the given calendar and time zone to\n\t    //    produce weekday, era, year, month, day, hour, minute, second, and inDST values.\n\t    //    The calculations should use best available information about the specified\n\t    //    calendar and time zone. If the calendar is \"gregory\", then the calculations must\n\t    //    match the algorithms specified in ES5, 15.9.1, except that calculations are not\n\t    //    bound by the restrictions on the use of best available information on time zones\n\t    //    for local time zone adjustment and daylight saving time adjustment imposed by\n\t    //    ES5, 15.9.1.7 and 15.9.1.8.\n\t    // ###TODO###\n\t    var d = new Date(date),\n\t        m = 'get' + (timeZone || '');\n\t\n\t    // 2. Return a Record with fields [[weekday]], [[era]], [[year]], [[month]], [[day]],\n\t    //    [[hour]], [[minute]], [[second]], and [[inDST]], each with the corresponding\n\t    //    calculated value.\n\t    return new Record({\n\t        '[[weekday]]': d[m + 'Day'](),\n\t        '[[era]]'    : +(d[m + 'FullYear']() >= 0),\n\t        '[[year]]'   : d[m + 'FullYear'](),\n\t        '[[month]]'  : d[m + 'Month'](),\n\t        '[[day]]'    : d[m + 'Date'](),\n\t        '[[hour]]'   : d[m + 'Hours'](),\n\t        '[[minute]]' : d[m + 'Minutes'](),\n\t        '[[second]]' : d[m + 'Seconds'](),\n\t        '[[inDST]]'  : false // ###TODO###\n\t    });\n\t}\n\t\n\t/**\n\t * The function returns a new object whose properties and attributes are set as if\n\t * constructed by an object literal assigning to each of the following properties the\n\t * value of the corresponding internal property of this DateTimeFormat object (see 12.4):\n\t * locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day,\n\t * hour, minute, second, and timeZoneName. Properties whose corresponding internal\n\t * properties are not present are not assigned.\n\t */\n\t/* 12.3.3 */defineProperty(Intl.DateTimeFormat.prototype, 'resolvedOptions', {\n\t    writable: true,\n\t    configurable: true,\n\t    value: function () {\n\t        var prop,\n\t            descs = new Record(),\n\t            props = [\n\t                'locale', 'calendar', 'numberingSystem', 'timeZone', 'hour12', 'weekday',\n\t                'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName'\n\t            ],\n\t            internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\t\n\t        // Satisfy test 12.3_b\n\t        if (!internal || !internal['[[initializedDateTimeFormat]]'])\n\t            throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.DateTimeFormat object.');\n\t\n\t        for (var i = 0, max = props.length; i < max; i++) {\n\t            if (hop.call(internal, prop = '[[' + props[i] + ']]'))\n\t                descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n\t        }\n\t\n\t        return objCreate({}, descs);\n\t    }\n\t});\n\t\n\t// Sect 13 Locale Sensitive Functions of the ECMAScript Language Specification\n\t// ===========================================================================\n\t\n\tvar ls = Intl.__localeSensitiveProtos = {\n\t    Number: {},\n\t    Date:   {}\n\t};\n\t\n\t/**\n\t * When the toLocaleString method is called with optional arguments locales and options,\n\t * the following steps are taken:\n\t */\n\t/* 13.2.1 */ls.Number.toLocaleString = function () {\n\t    // Satisfy test 13.2.1_1\n\t    if (Object.prototype.toString.call(this) !== '[object Number]')\n\t        throw new TypeError('`this` value must be a number for Number.prototype.toLocaleString()');\n\t\n\t    // 1. Let x be this Number value (as defined in ES5, 15.7.4).\n\t    // 2. If locales is not provided, then let locales be undefined.\n\t    // 3. If options is not provided, then let options be undefined.\n\t    // 4. Let numberFormat be the result of creating a new object as if by the\n\t    //    expression new Intl.NumberFormat(locales, options) where\n\t    //    Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n\t    // 5. Return the result of calling the FormatNumber abstract operation\n\t    //    (defined in 11.3.2) with arguments numberFormat and x.\n\t    return FormatNumber(new NumberFormatConstructor(arguments[0], arguments[1]), this);\n\t};\n\t\n\t/**\n\t * When the toLocaleString method is called with optional arguments locales and options,\n\t * the following steps are taken:\n\t */\n\t/* 13.3.1 */ls.Date.toLocaleString = function () {\n\t    // Satisfy test 13.3.0_1\n\t    if (Object.prototype.toString.call(this) !== '[object Date]')\n\t        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleString()');\n\t\n\t    var\n\t    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n\t        x = +this;\n\t\n\t    // 2. If x is NaN, then return \"Invalid Date\".\n\t    if (isNaN(x))\n\t        return 'Invalid Date';\n\t\n\t    var\n\t    // 3. If locales is not provided, then let locales be undefined.\n\t        locales = arguments[0],\n\t\n\t    // 4. If options is not provided, then let options be undefined.\n\t        options = arguments[1],\n\t\n\t    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n\t    //    operation (defined in 12.1.1) with arguments options, \"any\", and \"all\".\n\t        options = ToDateTimeOptions(options, 'any', 'all'),\n\t\n\t    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n\t    //    expression new Intl.DateTimeFormat(locales, options) where\n\t    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n\t        dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\t\n\t    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n\t    //    in 12.3.2) with arguments dateTimeFormat and x.\n\t    return FormatDateTime(dateTimeFormat, x);\n\t};\n\t\n\t/**\n\t * When the toLocaleDateString method is called with optional arguments locales and\n\t * options, the following steps are taken:\n\t */\n\t/* 13.3.2 */ls.Date.toLocaleDateString = function () {\n\t    // Satisfy test 13.3.0_1\n\t    if (Object.prototype.toString.call(this) !== '[object Date]')\n\t        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleDateString()');\n\t\n\t    var\n\t    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n\t        x = +this;\n\t\n\t    // 2. If x is NaN, then return \"Invalid Date\".\n\t    if (isNaN(x))\n\t        return 'Invalid Date';\n\t\n\t    var\n\t    // 3. If locales is not provided, then let locales be undefined.\n\t        locales = arguments[0],\n\t\n\t    // 4. If options is not provided, then let options be undefined.\n\t        options = arguments[1],\n\t\n\t    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n\t    //    operation (defined in 12.1.1) with arguments options, \"date\", and \"date\".\n\t        options = ToDateTimeOptions(options, 'date', 'date'),\n\t\n\t    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n\t    //    expression new Intl.DateTimeFormat(locales, options) where\n\t    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n\t        dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\t\n\t    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n\t    //    in 12.3.2) with arguments dateTimeFormat and x.\n\t    return FormatDateTime(dateTimeFormat, x);\n\t};\n\t\n\t/**\n\t * When the toLocaleTimeString method is called with optional arguments locales and\n\t * options, the following steps are taken:\n\t */\n\t/* 13.3.3 */ls.Date.toLocaleTimeString = function () {\n\t    // Satisfy test 13.3.0_1\n\t    if (Object.prototype.toString.call(this) !== '[object Date]')\n\t        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleTimeString()');\n\t\n\t    var\n\t    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n\t        x = +this;\n\t\n\t    // 2. If x is NaN, then return \"Invalid Date\".\n\t    if (isNaN(x))\n\t        return 'Invalid Date';\n\t\n\t    var\n\t    // 3. If locales is not provided, then let locales be undefined.\n\t        locales = arguments[0],\n\t\n\t    // 4. If options is not provided, then let options be undefined.\n\t        options = arguments[1],\n\t\n\t    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n\t    //    operation (defined in 12.1.1) with arguments options, \"time\", and \"time\".\n\t        options = ToDateTimeOptions(options, 'time', 'time'),\n\t\n\t    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n\t    //    expression new Intl.DateTimeFormat(locales, options) where\n\t    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n\t        dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\t\n\t    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n\t    //    in 12.3.2) with arguments dateTimeFormat and x.\n\t    return FormatDateTime(dateTimeFormat, x);\n\t};\n\t\n\tdefineProperty(Intl, '__applyLocaleSensitivePrototypes', {\n\t    writable: true,\n\t    configurable: true,\n\t    value: function () {\n\t        defineProperty(Number.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Number.toLocaleString });\n\t        // Need this here for IE 8, to avoid the _DontEnum_ bug\n\t        defineProperty(Date.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Date.toLocaleString });\n\t\n\t        for (var k in ls.Date) {\n\t            if (hop.call(ls.Date, k))\n\t                defineProperty(Date.prototype, k, { writable: true, configurable: true, value: ls.Date[k] });\n\t        }\n\t    }\n\t});\n\t\n\t/**\n\t * Can't really ship a single script with data for hundreds of locales, so we provide\n\t * this __addLocaleData method as a means for the developer to add the data on an\n\t * as-needed basis\n\t */\n\tdefineProperty(Intl, '__addLocaleData', {\n\t    value: function (data) {\n\t        if (!IsStructurallyValidLanguageTag(data.locale))\n\t            throw new Error(\"Object passed doesn't identify itself with a valid language tag\");\n\t\n\t        addLocaleData(data, data.locale);\n\t    }\n\t});\n\t\n\tfunction addLocaleData (data, tag) {\n\t    // Both NumberFormat and DateTimeFormat require number data, so throw if it isn't present\n\t    if (!data.number)\n\t        throw new Error(\"Object passed doesn't contain locale data for Intl.NumberFormat\");\n\t\n\t    var locale,\n\t        locales = [ tag ],\n\t        parts   = tag.split('-');\n\t\n\t    // Create fallbacks for locale data with scripts, e.g. Latn, Hans, Vaii, etc\n\t    if (parts.length > 2 && parts[1].length === 4)\n\t        arrPush.call(locales, parts[0] + '-' + parts[2]);\n\t\n\t    while (locale = arrShift.call(locales)) {\n\t        // Add to NumberFormat internal properties as per 11.2.3\n\t        arrPush.call(internals.NumberFormat['[[availableLocales]]'], locale);\n\t        internals.NumberFormat['[[localeData]]'][locale] = data.number;\n\t\n\t        // ...and DateTimeFormat internal properties as per 12.2.3\n\t        if (data.date) {\n\t            data.date.nu = data.number.nu;\n\t            arrPush.call(internals.DateTimeFormat['[[availableLocales]]'], locale);\n\t            internals.DateTimeFormat['[[localeData]]'][locale] = data.date;\n\t        }\n\t    }\n\t\n\t    // If this is the first set of locale data added, make it the default\n\t    if (defaultLocale === undefined)\n\t        defaultLocale = tag;\n\t\n\t    // 11.3 (the NumberFormat prototype object is an Intl.NumberFormat instance)\n\t    if (!numberFormatProtoInitialised) {\n\t        InitializeNumberFormat(Intl.NumberFormat.prototype);\n\t        numberFormatProtoInitialised = true;\n\t    }\n\t\n\t    // 11.3 (the NumberFormat prototype object is an Intl.NumberFormat instance)\n\t    if (data.date && !dateTimeFormatProtoInitialised) {\n\t        InitializeDateTimeFormat(Intl.DateTimeFormat.prototype);\n\t        dateTimeFormatProtoInitialised = true;\n\t    }\n\t}\n\t\n\t// Helper functions\n\t// ================\n\t\n\t/**\n\t * A function to deal with the inaccuracy of calculating log10 in pre-ES6\n\t * JavaScript environments. Math.log(num) / Math.LN10 was responsible for\n\t * causing issue #62.\n\t */\n\tfunction log10Floor (n) {\n\t    // ES6 provides the more accurate Math.log10\n\t    if (typeof Math.log10 === 'function')\n\t        return Math.floor(Math.log10(n));\n\t\n\t    var x = Math.round(Math.log(n) * Math.LOG10E);\n\t    return x - (Number('1e' + x) > n);\n\t}\n\t\n\t/**\n\t * A merge of the Intl.{Constructor}.supportedLocalesOf functions\n\t * To make life easier, the function should be bound to the constructor's internal\n\t * properties object.\n\t */\n\tfunction supportedLocalesOf(locales) {\n\t    /*jshint validthis:true */\n\t\n\t    // Bound functions only have the `this` value altered if being used as a constructor,\n\t    // this lets us imitate a native function that has no constructor\n\t    if (!hop.call(this, '[[availableLocales]]'))\n\t        throw new TypeError('supportedLocalesOf() is not a constructor');\n\t\n\t    var\n\t    // Create an object whose props can be used to restore the values of RegExp props\n\t        regexpState = createRegExpRestore(),\n\t\n\t    // 1. If options is not provided, then let options be undefined.\n\t        options = arguments[1],\n\t\n\t    // 2. Let availableLocales be the value of the [[availableLocales]] internal\n\t    //    property of the standard built-in object that is the initial value of\n\t    //    Intl.NumberFormat.\n\t\n\t        availableLocales = this['[[availableLocales]]'],\n\t\n\t    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n\t    //    abstract operation (defined in 9.2.1) with argument locales.\n\t        requestedLocales = CanonicalizeLocaleList(locales);\n\t\n\t    // Restore the RegExp properties\n\t    regexpState.exp.test(regexpState.input);\n\t\n\t    // 4. Return the result of calling the SupportedLocales abstract operation\n\t    //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n\t    //    and options.\n\t    return SupportedLocales(availableLocales, requestedLocales, options);\n\t}\n\t\n\t/**\n\t * Returns a string for a date component, resolved using multiple inheritance as specified\n\t * as specified in the Unicode Technical Standard 35.\n\t */\n\tfunction resolveDateString(data, ca, component, width, key) {\n\t    // From http://www.unicode.org/reports/tr35/tr35.html#Multiple_Inheritance:\n\t    // 'In clearly specified instances, resources may inherit from within the same locale.\n\t    //  For example, ... the Buddhist calendar inherits from the Gregorian calendar.'\n\t    var obj = data[ca] && data[ca][component]\n\t                ? data[ca][component]\n\t                : data.gregory[component],\n\t\n\t        // \"sideways\" inheritance resolves strings when a key doesn't exist\n\t        alts = {\n\t            narrow: ['short', 'long'],\n\t            short:  ['long', 'narrow'],\n\t            long:   ['short', 'narrow']\n\t        },\n\t\n\t        //\n\t        resolved = hop.call(obj, width)\n\t                  ? obj[width]\n\t                  : hop.call(obj, alts[width][0])\n\t                      ? obj[alts[width][0]]\n\t                      : obj[alts[width][1]];\n\t\n\t    // `key` wouldn't be specified for components 'dayPeriods'\n\t    return key != null ? resolved[key] : resolved;\n\t}\n\t\n\t/**\n\t * A map that doesn't contain Object in its prototype chain\n\t */\n\tRecord.prototype = objCreate(null);\n\tfunction Record (obj) {\n\t    // Copy only own properties over unless this object is already a Record instance\n\t    for (var k in obj) {\n\t        if (obj instanceof Record || hop.call(obj, k))\n\t            defineProperty(this, k, { value: obj[k], enumerable: true, writable: true, configurable: true });\n\t    }\n\t}\n\t\n\t/**\n\t * An ordered list\n\t */\n\tList.prototype = objCreate(null);\n\tfunction List() {\n\t    defineProperty(this, 'length', { writable:true, value: 0 });\n\t\n\t    if (arguments.length)\n\t        arrPush.apply(this, arrSlice.call(arguments));\n\t}\n\t\n\t/**\n\t * Constructs a regular expression to restore tainted RegExp properties\n\t */\n\tfunction createRegExpRestore () {\n\t    var esc = /[.?*+^$[\\]\\\\(){}|-]/g,\n\t        lm  = RegExp.lastMatch || '',\n\t        ml  = RegExp.multiline ? 'm' : '',\n\t        ret = { input: RegExp.input },\n\t        reg = new List(),\n\t        has = false,\n\t        cap = {};\n\t\n\t    // Create a snapshot of all the 'captured' properties\n\t    for (var i = 1; i <= 9; i++)\n\t        has = (cap['$'+i] = RegExp['$'+i]) || has;\n\t\n\t    // Now we've snapshotted some properties, escape the lastMatch string\n\t    lm = lm.replace(esc, '\\\\$&');\n\t\n\t    // If any of the captured strings were non-empty, iterate over them all\n\t    if (has) {\n\t        for (var i = 1; i <= 9; i++) {\n\t            var m = cap['$'+i];\n\t\n\t            // If it's empty, add an empty capturing group\n\t            if (!m)\n\t                lm = '()' + lm;\n\t\n\t            // Else find the string in lm and escape & wrap it to capture it\n\t            else {\n\t                m = m.replace(esc, '\\\\$&');\n\t                lm = lm.replace(m, '(' + m + ')');\n\t            }\n\t\n\t            // Push it to the reg and chop lm to make sure further groups come after\n\t            arrPush.call(reg, lm.slice(0, lm.indexOf('(') + 1));\n\t            lm = lm.slice(lm.indexOf('(') + 1);\n\t        }\n\t    }\n\t\n\t    // Create the regular expression that will reconstruct the RegExp properties\n\t    ret.exp = new RegExp(arrJoin.call(reg, '') + lm, ml);\n\t\n\t    return ret;\n\t}\n\t\n\t/**\n\t * Convert only a-z to uppercase as per section 6.1 of the spec\n\t */\n\tfunction toLatinUpperCase (str) {\n\t    var i = str.length;\n\t\n\t    while (i--) {\n\t        var ch = str.charAt(i);\n\t\n\t        if (ch >= \"a\" && ch <= \"z\")\n\t            str = str.slice(0, i) + ch.toUpperCase() + str.slice(i+1);\n\t    }\n\t\n\t    return str;\n\t}\n\t\n\t/**\n\t * Mimics ES5's abstract ToObject() function\n\t */\n\tfunction toObject (arg) {\n\t    if (arg == null)\n\t        throw new TypeError('Cannot convert null or undefined to object');\n\t\n\t    return Object(arg);\n\t}\n\t\n\t/**\n\t * Returns \"internal\" properties for an object\n\t */\n\tfunction getInternalProperties (obj) {\n\t    if (hop.call(obj, '__getInternalProperties'))\n\t        return obj.__getInternalProperties(secret);\n\t    else\n\t        return objCreate(null);\n\t}\n\t\n\texports[\"default\"] = Intl;\n\t\n\t//# sourceMappingURL=core.js.map\n\n/***/ },\n\n/***/ 223:\n/***/ function(module, exports) {\n\n\t/* jshint esnext: true, laxbreak:true */\n\t\n\t/**\n\t* Defines regular expressions for various operations related to the BCP 47 syntax,\n\t* as defined at http://tools.ietf.org/html/bcp47#section-2.1\n\t*/\n\t\n\t\"use strict\";\n\t\n\tvar\n\t    // extlang       = 3ALPHA              ; selected ISO 639 codes\n\t    //                 *2(\"-\" 3ALPHA)      ; permanently reserved\n\t    extlang = '[a-z]{3}(?:-[a-z]{3}){0,2}',\n\t\n\t    // language      = 2*3ALPHA            ; shortest ISO 639 code\n\t    //                 [\"-\" extlang]       ; sometimes followed by\n\t    //                                     ; extended language subtags\n\t    //               / 4ALPHA              ; or reserved for future use\n\t    //               / 5*8ALPHA            ; or registered language subtag\n\t    language = '(?:[a-z]{2,3}(?:-' + extlang + ')?|[a-z]{4}|[a-z]{5,8})',\n\t\n\t    // script        = 4ALPHA              ; ISO 15924 code\n\t    script = '[a-z]{4}',\n\t\n\t    // region        = 2ALPHA              ; ISO 3166-1 code\n\t    //               / 3DIGIT              ; UN M.49 code\n\t    region = '(?:[a-z]{2}|\\\\d{3})',\n\t\n\t    // variant       = 5*8alphanum         ; registered variants\n\t    //               / (DIGIT 3alphanum)\n\t    variant = '(?:[a-z0-9]{5,8}|\\\\d[a-z0-9]{3})',\n\t\n\t    //                                     ; Single alphanumerics\n\t    //                                     ; \"x\" reserved for private use\n\t    // singleton     = DIGIT               ; 0 - 9\n\t    //               / %x41-57             ; A - W\n\t    //               / %x59-5A             ; Y - Z\n\t    //               / %x61-77             ; a - w\n\t    //               / %x79-7A             ; y - z\n\t    singleton = '[0-9a-wy-z]',\n\t\n\t    // extension     = singleton 1*(\"-\" (2*8alphanum))\n\t    extension = singleton + '(?:-[a-z0-9]{2,8})+',\n\t\n\t    // privateuse    = \"x\" 1*(\"-\" (1*8alphanum))\n\t    privateuse = 'x(?:-[a-z0-9]{1,8})+',\n\t\n\t    // irregular     = \"en-GB-oed\"         ; irregular tags do not match\n\t    //               / \"i-ami\"             ; the 'langtag' production and\n\t    //               / \"i-bnn\"             ; would not otherwise be\n\t    //               / \"i-default\"         ; considered 'well-formed'\n\t    //               / \"i-enochian\"        ; These tags are all valid,\n\t    //               / \"i-hak\"             ; but most are deprecated\n\t    //               / \"i-klingon\"         ; in favor of more modern\n\t    //               / \"i-lux\"             ; subtags or subtag\n\t    //               / \"i-mingo\"           ; combination\n\t    //               / \"i-navajo\"\n\t    //               / \"i-pwn\"\n\t    //               / \"i-tao\"\n\t    //               / \"i-tay\"\n\t    //               / \"i-tsu\"\n\t    //               / \"sgn-BE-FR\"\n\t    //               / \"sgn-BE-NL\"\n\t    //               / \"sgn-CH-DE\"\n\t    irregular = '(?:en-GB-oed'\n\t              + '|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)'\n\t              + '|sgn-(?:BE-FR|BE-NL|CH-DE))',\n\t\n\t    // regular       = \"art-lojban\"        ; these tags match the 'langtag'\n\t    //               / \"cel-gaulish\"       ; production, but their subtags\n\t    //               / \"no-bok\"            ; are not extended language\n\t    //               / \"no-nyn\"            ; or variant subtags: their meaning\n\t    //               / \"zh-guoyu\"          ; is defined by their registration\n\t    //               / \"zh-hakka\"          ; and all of these are deprecated\n\t    //               / \"zh-min\"            ; in favor of a more modern\n\t    //               / \"zh-min-nan\"        ; subtag or sequence of subtags\n\t    //               / \"zh-xiang\"\n\t    regular = '(?:art-lojban|cel-gaulish|no-bok|no-nyn'\n\t            + '|zh-(?:guoyu|hakka|min|min-nan|xiang))',\n\t\n\t    // grandfathered = irregular           ; non-redundant tags registered\n\t    //               / regular             ; during the RFC 3066 era\n\t    grandfathered = '(?:' + irregular + '|' + regular + ')',\n\t\n\t    // langtag       = language\n\t    //                 [\"-\" script]\n\t    //                 [\"-\" region]\n\t    //                 *(\"-\" variant)\n\t    //                 *(\"-\" extension)\n\t    //                 [\"-\" privateuse]\n\t    langtag = language + '(?:-' + script + ')?(?:-' + region + ')?(?:-'\n\t            + variant + ')*(?:-' + extension + ')*(?:-' + privateuse + ')?';\n\t\n\tvar expBCP47Syntax = RegExp('^(?:'+langtag+'|'+privateuse+'|'+grandfathered+')$', 'i');\n\t\n\tvar expVariantDupes = RegExp('^(?!x).*?-('+variant+')-(?:\\\\w{4,8}-(?!x-))*\\\\1\\\\b', 'i');\n\t\n\tvar expSingletonDupes = RegExp('^(?!x).*?-('+singleton+')-(?:\\\\w+-(?!x-))*\\\\1\\\\b', 'i');\n\t\n\tvar expExtSequences = RegExp('-'+extension, 'ig');\n\texports.expBCP47Syntax = expBCP47Syntax, exports.expVariantDupes = expVariantDupes, exports.expSingletonDupes = expSingletonDupes, exports.expExtSequences = expExtSequences;\n\t\n\t//# sourceMappingURL=exp.js.map\n\n/***/ },\n\n/***/ 397:\n395\n\n});\n\n\n/** WEBPACK FOOTER **\n ** intl-2836431f5a13e9e641e8.js\n **/","var m = require('./lib/core.js'),\n    IntlPolyfill = m.default;\n\n// Expose `IntlPolyfill` as global to add locale data into runtime later on.\nglobal.IntlPolyfill = IntlPolyfill;\n\n// Require all locale data for `Intl`. This module will be\n// ignored when bundling for the browser with Browserify/Webpack.\nrequire('./locale-data/complete.js');\n\n// hack to export the polyfill as global Intl if needed\nif (!global.Intl) {\n    global.Intl = IntlPolyfill;\n    IntlPolyfill.__applyLocaleSensitivePrototypes();\n}\n\n// providing an idiomatic api for the nodejs version of this module\nmodule.exports = exports = IntlPolyfill;\n// preserving the original api in case another module is relying on that\nexports.default = IntlPolyfill;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/intl/index.js\n ** module id = 112\n ** module chunks = 1\n **/","/* jslint esnext: true */\n\n// Match these datetime components in a CLDR pattern, except those in single quotes\n\"use strict\";\nexports.createDateTimeFormat = createDateTimeFormat, exports.createDateTimeFormats = createDateTimeFormats;\nvar expDTComponents = /(?:[Eec]{1,6}|G{1,5}|(?:[yYu]+|U{1,5})|[ML]{1,5}|d{1,2}|a|[hkHK]{1,2}|m{1,2}|s{1,2}|z{1,4})(?=([^']*'[^']*')*[^']*$)/g;\n\n// Skip over patterns with these datetime components\nvar unwantedDTCs = /[QxXVOvZASjgFDwWIQqH]/;\n\n// Maps the number of characters in a CLDR pattern to the specification\nvar dtcLengthMap = {\n        month:   [ 'numeric', '2-digit', 'short', 'long', 'narrow' ],\n        weekday: [ 'short', 'short', 'short', 'long', 'narrow' ],\n        era:     [ 'short', 'short', 'short', 'long', 'narrow' ]\n    };\n\nvar dtKeys = [\"weekday\", \"era\", \"year\", \"month\", \"day\"];\nvar tmKeys = [\"hour\", \"minute\", \"second\", \"timeZoneName\"];\n\nfunction isDateFormatOnly(obj) {\n    for (var i = 0; i < tmKeys.length; i += 1) {\n        if (obj.hasOwnProperty(tmKeys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isTimeFormatOnly(obj) {\n    for (var i = 0; i < dtKeys.length; i += 1) {\n        if (obj.hasOwnProperty(dtKeys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction createDateTimeFormat(format) {\n    if (unwantedDTCs.test(format))\n        return undefined;\n\n    var formatObj = {};\n\n    // Replace the pattern string with the one required by the specification, whilst\n    // at the same time evaluating it for the subsets and formats\n    formatObj.pattern = format.replace(expDTComponents, function ($0) {\n        // See which symbol we're dealing with\n        switch ($0.charAt(0)) {\n            case 'E':\n            case 'e':\n            case 'c':\n                formatObj.weekday = dtcLengthMap.weekday[$0.length-1];\n                return '{weekday}';\n\n            // Not supported yet\n            case 'G':\n                formatObj.era = dtcLengthMap.era[$0.length-1];\n                return '{era}';\n\n            case 'y':\n            case 'Y':\n            case 'u':\n            case 'U':\n                formatObj.year = $0.length === 2 ? '2-digit' : 'numeric';\n                return '{year}';\n\n            case 'M':\n            case 'L':\n                formatObj.month = dtcLengthMap.month[$0.length-1];\n                return '{month}';\n\n            case 'd':\n                formatObj.day = $0.length === 2 ? '2-digit' : 'numeric';\n                return '{day}';\n\n            case 'a':\n                return '{ampm}';\n\n            case 'h':\n            case 'H':\n            case 'k':\n            case 'K':\n                formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n                return '{hour}';\n\n            case 'm':\n                formatObj.minute = $0.length === 2 ? '2-digit' : 'numeric';\n                return '{minute}';\n\n            case 's':\n                formatObj.second = $0.length === 2 ? '2-digit' : 'numeric';\n                return '{second}';\n\n            case 'z':\n                formatObj.timeZoneName = $0.length < 4 ? 'short' : 'long';\n                return '{timeZoneName}';\n        }\n    });\n\n    // From http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns:\n    //  'In patterns, two single quotes represents a literal single quote, either\n    //   inside or outside single quotes. Text within single quotes is not\n    //   interpreted in any way (except for two adjacent single quotes).'\n    formatObj.pattern = formatObj.pattern.replace(/'([^']*)'/g, function ($0, literal) {\n        return literal ? literal : \"'\";\n    });\n\n    if (formatObj.pattern.indexOf('{ampm}') > -1) {\n        formatObj.hour12 = true;\n        formatObj.pattern12 = formatObj.pattern;\n        formatObj.pattern = formatObj.pattern.replace('{ampm}', '').replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n    }\n\n    return formatObj;\n}\n\nfunction createDateTimeFormats(formats) {\n    var availableFormats = formats.availableFormats;\n    var timeFormats = formats.timeFormats;\n    var dateFormats = formats.dateFormats;\n    var order = formats.medium;\n    var result = [];\n    var key, format, computed, i, j;\n    var timeRelatedFormats = [];\n    var dateRelatedFormats = [];\n\n    function expandFormat(key, pattern) {\n        // Expand component lengths if necessary, as allowed in the LDML spec\n        // Get the lengths of 'M' and 'E' substrings in the date pattern\n        // as arrays that can be joined to create a new substring\n        var M = new Array((key.match(/M/g)||[]).length + 1);\n        var E = new Array((key.match(/E/g)||[]).length + 1);\n\n        // note from caridy: I'm not sure we really need this, seems to be\n        //                   useless since it relies on the keys from CLDR\n        //                   instead of the actual format pattern, but I'm not sure.\n        if (M.length > 2)\n            pattern = pattern.replace(/(M|L)+/, M.join('$1'));\n\n        if (E.length > 2)\n            pattern = pattern.replace(/([Eec])+/, E.join('$1'));\n\n        return pattern;\n    }\n\n    // Map available (custom) formats into a pattern for createDateTimeFormats\n    for (key in availableFormats) {\n        if (availableFormats.hasOwnProperty(key)) {\n            format = expandFormat(key, availableFormats[key]);\n            computed = createDateTimeFormat(format);\n            if (computed) {\n                result.push(computed);\n                // in some cases, the format is only displaying date specific props\n                // or time specific props, in which case we need to also produce the\n                // combined formats.\n                if (isDateFormatOnly(computed)) {\n                    dateRelatedFormats.push(format);\n                } else if (isTimeFormatOnly(computed)) {\n                    timeRelatedFormats.push(format);\n                }\n            }\n        }\n    }\n\n    // combine custom time and custom date formats when they are orthogonals to complete the\n    // formats supported by browsers by relying on the value of \"formats.medium\" which defines\n    // how to join custom formats into a single pattern.\n    for (i = 0; i < timeRelatedFormats.length; i += 1) {\n        for (j = 0; j < dateRelatedFormats.length; j += 1) {\n            format = order\n                .replace('{0}', timeRelatedFormats[i])\n                .replace('{1}', dateRelatedFormats[j])\n                .replace(/^[,\\s]+|[,\\s]+$/gi, '');\n            computed = createDateTimeFormat(format);\n            if (computed) {\n                result.push(computed);\n            }\n        }\n    }\n\n    // Map time formats into a pattern for createDateTimeFormats\n    for (key in timeFormats) {\n        if (timeFormats.hasOwnProperty(key)) {\n            format = expandFormat(key, timeFormats[key]);\n            computed = createDateTimeFormat(format);\n            if (computed) {\n                result.push(computed);\n            }\n        }\n    }\n\n    // Map date formats into a pattern for createDateTimeFormats\n    for (key in dateFormats) {\n        if (dateFormats.hasOwnProperty(key)) {\n            format = expandFormat(key, dateFormats[key]);\n            computed = createDateTimeFormat(format);\n            if (computed) {\n                result.push(computed);\n            }\n        }\n    }\n\n    return result;\n}\n\n//# sourceMappingURL=cldr.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/intl/lib/cldr.js\n ** module id = 221\n ** module chunks = 1\n **/","/**\n * @license Copyright 2013 Andy Earnshaw, MIT License\n *\n * Implements the ECMAScript Internationalization API in ES5-compatible environments,\n * following the ECMA-402 specification as closely as possible\n *\n * ECMA-402: http://ecma-international.org/ecma-402/1.0/\n *\n * CLDR format locale data should be provided using IntlPolyfill.__addLocaleData().\n */\n/*jshint esnext: true, proto:true, eqnull:true, boss:true, laxbreak:true, newcap:false, shadow:true, funcscope:true */\n\n\"use strict\";\nvar src$exp$$ = require(\"./exp\"), src$cldr$$ = require(\"./cldr\");\n\nvar Intl = {},\n\n    realDefineProp = (function () {\n        var sentinel = {};\n        try {\n            Object.defineProperty(sentinel, 'a', {});\n            return 'a' in sentinel;\n        } catch (e) {\n            return false;\n        }\n    })(),\n\n    // Need a workaround for getters in ES3\n    es3  = !realDefineProp && !Object.prototype.__defineGetter__,\n\n    // We use this a lot (and need it for proto-less objects)\n    hop = Object.prototype.hasOwnProperty,\n\n    // Naive defineProperty for compatibility\n    defineProperty = realDefineProp ? Object.defineProperty : function (obj, name, desc) {\n        if ('get' in desc && obj.__defineGetter__)\n            obj.__defineGetter__(name, desc.get);\n\n        else if (!hop.call(obj, name) || 'value' in desc)\n            obj[name] = desc.value;\n    },\n\n    // Array.prototype.indexOf, as good as we need it to be\n    arrIndexOf = Array.prototype.indexOf || function (search) {\n        /*jshint validthis:true */\n        var t = this;\n        if (!t.length)\n            return -1;\n\n        for (var i = arguments[1] || 0, max = t.length; i < max; i++) {\n            if (t[i] === search)\n                return i;\n        }\n\n        return -1;\n    },\n\n    // Create an object with the specified prototype (2nd arg required for Record)\n    objCreate = Object.create || function (proto, props) {\n        var obj;\n\n        function F() {}\n        F.prototype = proto;\n        obj = new F();\n\n        for (var k in props) {\n            if (hop.call(props, k))\n                defineProperty(obj, k, props[k]);\n        }\n\n        return obj;\n    },\n\n    // Snapshot some (hopefully still) native built-ins\n    arrSlice  = Array.prototype.slice,\n    arrConcat = Array.prototype.concat,\n    arrPush   = Array.prototype.push,\n    arrJoin   = Array.prototype.join,\n    arrShift  = Array.prototype.shift,\n    arrUnshift= Array.prototype.unshift,\n\n    // Naive Function.prototype.bind for compatibility\n    fnBind = Function.prototype.bind || function (thisObj) {\n        var fn = this,\n            args = arrSlice.call(arguments, 1);\n\n        // All our (presently) bound functions have either 1 or 0 arguments. By returning\n        // different function signatures, we can pass some tests in ES3 environments\n        if (fn.length === 1) {\n            return function (a) {\n                return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n            };\n        }\n        else {\n            return function () {\n                return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n            };\n        }\n    },\n\n    // Default locale is the first-added locale data for us\n    defaultLocale,\n\n    // Object housing internal properties for constructors\n    internals = objCreate(null),\n\n    // Keep internal properties internal\n    secret = Math.random(),\n\n    // An object map of date component keys, saves using a regex later\n    dateWidths = objCreate(null, { narrow:{}, short:{}, long:{} }),\n\n    // Each constructor prototype should be an instance of the constructor itself, but we\n    // can't initialise them as such until some locale data has been added, so this is how\n    // we keep track\n    numberFormatProtoInitialised = false,\n    dateTimeFormatProtoInitialised = false,\n\n    // Some regular expressions we're using\n    expCurrencyCode = /^[A-Z]{3}$/,\n    expUnicodeExSeq = /-u(?:-[0-9a-z]{2,8})+/gi, // See `extension` below\n\n    // IANA Subtag Registry redundant tag and subtag maps\n    redundantTags = {\n        tags: {\n            \"art-lojban\":   \"jbo\",       \"i-ami\":        \"ami\",       \"i-bnn\":       \"bnn\",  \"i-hak\":      \"hak\",\n            \"i-klingon\":    \"tlh\",       \"i-lux\":        \"lb\",        \"i-navajo\":    \"nv\",   \"i-pwn\":      \"pwn\",\n            \"i-tao\":        \"tao\",       \"i-tay\":        \"tay\",       \"i-tsu\":       \"tsu\",  \"no-bok\":     \"nb\",\n            \"no-nyn\":       \"nn\",        \"sgn-BE-FR\":    \"sfb\",       \"sgn-BE-NL\":   \"vgt\",  \"sgn-CH-DE\":  \"sgg\",\n            \"zh-guoyu\":     \"cmn\",       \"zh-hakka\":     \"hak\",       \"zh-min-nan\":  \"nan\",  \"zh-xiang\":   \"hsn\",\n            \"sgn-BR\":       \"bzs\",       \"sgn-CO\":       \"csn\",       \"sgn-DE\":      \"gsg\",  \"sgn-DK\":     \"dsl\",\n            \"sgn-ES\":       \"ssp\",       \"sgn-FR\":       \"fsl\",       \"sgn-GB\":      \"bfi\",  \"sgn-GR\":     \"gss\",\n            \"sgn-IE\":       \"isg\",       \"sgn-IT\":       \"ise\",       \"sgn-JP\":      \"jsl\",  \"sgn-MX\":     \"mfs\",\n            \"sgn-NI\":       \"ncs\",       \"sgn-NL\":       \"dse\",       \"sgn-NO\":      \"nsl\",  \"sgn-PT\":     \"psr\",\n            \"sgn-SE\":       \"swl\",       \"sgn-US\":       \"ase\",       \"sgn-ZA\":      \"sfs\",  \"zh-cmn\":     \"cmn\",\n            \"zh-cmn-Hans\":  \"cmn-Hans\",  \"zh-cmn-Hant\":  \"cmn-Hant\",  \"zh-gan\":      \"gan\",  \"zh-wuu\":     \"wuu\",\n            \"zh-yue\":       \"yue\"\n        },\n        subtags: {\n              BU: \"MM\",   DD: \"DE\",   FX: \"FR\",   TP: \"TL\",   YD: \"YE\",   ZR: \"CD\",  heploc: \"alalc97\",\n            'in': \"id\",   iw: \"he\",   ji:  \"yi\",  jw: \"jv\",   mo: \"ro\",  ayx: \"nun\", bjd: \"drl\",\n             ccq: \"rki\", cjr: \"mom\", cka: \"cmr\", cmk: \"xch\", drh: \"khk\", drw: \"prs\", gav: \"dev\",\n             hrr: \"jal\", ibi: \"opa\", kgh: \"kml\", lcq: \"ppr\", mst: \"mry\", myt: \"mry\", sca: \"hle\",\n             tie: \"ras\", tkk: \"twm\", tlw: \"weo\", tnf: \"prs\", ybd: \"rki\", yma: \"lrr\"\n        },\n        extLang: {\n            aao: [ \"aao\", \"ar\"  ], abh: [ \"abh\", \"ar\"  ], abv: [ \"abv\", \"ar\"  ], acm: [ \"acm\", \"ar\"  ],\n            acq: [ \"acq\", \"ar\"  ], acw: [ \"acw\", \"ar\"  ], acx: [ \"acx\", \"ar\"  ], acy: [ \"acy\", \"ar\"  ],\n            adf: [ \"adf\", \"ar\"  ], ads: [ \"ads\", \"sgn\" ], aeb: [ \"aeb\", \"ar\"  ], aec: [ \"aec\", \"ar\"  ],\n            aed: [ \"aed\", \"sgn\" ], aen: [ \"aen\", \"sgn\" ], afb: [ \"afb\", \"ar\"  ], afg: [ \"afg\", \"sgn\" ],\n            ajp: [ \"ajp\", \"ar\"  ], apc: [ \"apc\", \"ar\"  ], apd: [ \"apd\", \"ar\"  ], arb: [ \"arb\", \"ar\"  ],\n            arq: [ \"arq\", \"ar\"  ], ars: [ \"ars\", \"ar\"  ], ary: [ \"ary\", \"ar\"  ], arz: [ \"arz\", \"ar\"  ],\n            ase: [ \"ase\", \"sgn\" ], asf: [ \"asf\", \"sgn\" ], asp: [ \"asp\", \"sgn\" ], asq: [ \"asq\", \"sgn\" ],\n            asw: [ \"asw\", \"sgn\" ], auz: [ \"auz\", \"ar\"  ], avl: [ \"avl\", \"ar\"  ], ayh: [ \"ayh\", \"ar\"  ],\n            ayl: [ \"ayl\", \"ar\"  ], ayn: [ \"ayn\", \"ar\"  ], ayp: [ \"ayp\", \"ar\"  ], bbz: [ \"bbz\", \"ar\"  ],\n            bfi: [ \"bfi\", \"sgn\" ], bfk: [ \"bfk\", \"sgn\" ], bjn: [ \"bjn\", \"ms\"  ], bog: [ \"bog\", \"sgn\" ],\n            bqn: [ \"bqn\", \"sgn\" ], bqy: [ \"bqy\", \"sgn\" ], btj: [ \"btj\", \"ms\"  ], bve: [ \"bve\", \"ms\"  ],\n            bvl: [ \"bvl\", \"sgn\" ], bvu: [ \"bvu\", \"ms\"  ], bzs: [ \"bzs\", \"sgn\" ], cdo: [ \"cdo\", \"zh\"  ],\n            cds: [ \"cds\", \"sgn\" ], cjy: [ \"cjy\", \"zh\"  ], cmn: [ \"cmn\", \"zh\"  ], coa: [ \"coa\", \"ms\"  ],\n            cpx: [ \"cpx\", \"zh\"  ], csc: [ \"csc\", \"sgn\" ], csd: [ \"csd\", \"sgn\" ], cse: [ \"cse\", \"sgn\" ],\n            csf: [ \"csf\", \"sgn\" ], csg: [ \"csg\", \"sgn\" ], csl: [ \"csl\", \"sgn\" ], csn: [ \"csn\", \"sgn\" ],\n            csq: [ \"csq\", \"sgn\" ], csr: [ \"csr\", \"sgn\" ], czh: [ \"czh\", \"zh\"  ], czo: [ \"czo\", \"zh\"  ],\n            doq: [ \"doq\", \"sgn\" ], dse: [ \"dse\", \"sgn\" ], dsl: [ \"dsl\", \"sgn\" ], dup: [ \"dup\", \"ms\"  ],\n            ecs: [ \"ecs\", \"sgn\" ], esl: [ \"esl\", \"sgn\" ], esn: [ \"esn\", \"sgn\" ], eso: [ \"eso\", \"sgn\" ],\n            eth: [ \"eth\", \"sgn\" ], fcs: [ \"fcs\", \"sgn\" ], fse: [ \"fse\", \"sgn\" ], fsl: [ \"fsl\", \"sgn\" ],\n            fss: [ \"fss\", \"sgn\" ], gan: [ \"gan\", \"zh\"  ], gds: [ \"gds\", \"sgn\" ], gom: [ \"gom\", \"kok\" ],\n            gse: [ \"gse\", \"sgn\" ], gsg: [ \"gsg\", \"sgn\" ], gsm: [ \"gsm\", \"sgn\" ], gss: [ \"gss\", \"sgn\" ],\n            gus: [ \"gus\", \"sgn\" ], hab: [ \"hab\", \"sgn\" ], haf: [ \"haf\", \"sgn\" ], hak: [ \"hak\", \"zh\"  ],\n            hds: [ \"hds\", \"sgn\" ], hji: [ \"hji\", \"ms\"  ], hks: [ \"hks\", \"sgn\" ], hos: [ \"hos\", \"sgn\" ],\n            hps: [ \"hps\", \"sgn\" ], hsh: [ \"hsh\", \"sgn\" ], hsl: [ \"hsl\", \"sgn\" ], hsn: [ \"hsn\", \"zh\"  ],\n            icl: [ \"icl\", \"sgn\" ], ils: [ \"ils\", \"sgn\" ], inl: [ \"inl\", \"sgn\" ], ins: [ \"ins\", \"sgn\" ],\n            ise: [ \"ise\", \"sgn\" ], isg: [ \"isg\", \"sgn\" ], isr: [ \"isr\", \"sgn\" ], jak: [ \"jak\", \"ms\"  ],\n            jax: [ \"jax\", \"ms\"  ], jcs: [ \"jcs\", \"sgn\" ], jhs: [ \"jhs\", \"sgn\" ], jls: [ \"jls\", \"sgn\" ],\n            jos: [ \"jos\", \"sgn\" ], jsl: [ \"jsl\", \"sgn\" ], jus: [ \"jus\", \"sgn\" ], kgi: [ \"kgi\", \"sgn\" ],\n            knn: [ \"knn\", \"kok\" ], kvb: [ \"kvb\", \"ms\"  ], kvk: [ \"kvk\", \"sgn\" ], kvr: [ \"kvr\", \"ms\"  ],\n            kxd: [ \"kxd\", \"ms\"  ], lbs: [ \"lbs\", \"sgn\" ], lce: [ \"lce\", \"ms\"  ], lcf: [ \"lcf\", \"ms\"  ],\n            liw: [ \"liw\", \"ms\"  ], lls: [ \"lls\", \"sgn\" ], lsg: [ \"lsg\", \"sgn\" ], lsl: [ \"lsl\", \"sgn\" ],\n            lso: [ \"lso\", \"sgn\" ], lsp: [ \"lsp\", \"sgn\" ], lst: [ \"lst\", \"sgn\" ], lsy: [ \"lsy\", \"sgn\" ],\n            ltg: [ \"ltg\", \"lv\"  ], lvs: [ \"lvs\", \"lv\"  ], lzh: [ \"lzh\", \"zh\"  ], max: [ \"max\", \"ms\"  ],\n            mdl: [ \"mdl\", \"sgn\" ], meo: [ \"meo\", \"ms\"  ], mfa: [ \"mfa\", \"ms\"  ], mfb: [ \"mfb\", \"ms\"  ],\n            mfs: [ \"mfs\", \"sgn\" ], min: [ \"min\", \"ms\"  ], mnp: [ \"mnp\", \"zh\"  ], mqg: [ \"mqg\", \"ms\"  ],\n            mre: [ \"mre\", \"sgn\" ], msd: [ \"msd\", \"sgn\" ], msi: [ \"msi\", \"ms\"  ], msr: [ \"msr\", \"sgn\" ],\n            mui: [ \"mui\", \"ms\"  ], mzc: [ \"mzc\", \"sgn\" ], mzg: [ \"mzg\", \"sgn\" ], mzy: [ \"mzy\", \"sgn\" ],\n            nan: [ \"nan\", \"zh\"  ], nbs: [ \"nbs\", \"sgn\" ], ncs: [ \"ncs\", \"sgn\" ], nsi: [ \"nsi\", \"sgn\" ],\n            nsl: [ \"nsl\", \"sgn\" ], nsp: [ \"nsp\", \"sgn\" ], nsr: [ \"nsr\", \"sgn\" ], nzs: [ \"nzs\", \"sgn\" ],\n            okl: [ \"okl\", \"sgn\" ], orn: [ \"orn\", \"ms\"  ], ors: [ \"ors\", \"ms\"  ], pel: [ \"pel\", \"ms\"  ],\n            pga: [ \"pga\", \"ar\"  ], pks: [ \"pks\", \"sgn\" ], prl: [ \"prl\", \"sgn\" ], prz: [ \"prz\", \"sgn\" ],\n            psc: [ \"psc\", \"sgn\" ], psd: [ \"psd\", \"sgn\" ], pse: [ \"pse\", \"ms\"  ], psg: [ \"psg\", \"sgn\" ],\n            psl: [ \"psl\", \"sgn\" ], pso: [ \"pso\", \"sgn\" ], psp: [ \"psp\", \"sgn\" ], psr: [ \"psr\", \"sgn\" ],\n            pys: [ \"pys\", \"sgn\" ], rms: [ \"rms\", \"sgn\" ], rsi: [ \"rsi\", \"sgn\" ], rsl: [ \"rsl\", \"sgn\" ],\n            sdl: [ \"sdl\", \"sgn\" ], sfb: [ \"sfb\", \"sgn\" ], sfs: [ \"sfs\", \"sgn\" ], sgg: [ \"sgg\", \"sgn\" ],\n            sgx: [ \"sgx\", \"sgn\" ], shu: [ \"shu\", \"ar\"  ], slf: [ \"slf\", \"sgn\" ], sls: [ \"sls\", \"sgn\" ],\n            sqk: [ \"sqk\", \"sgn\" ], sqs: [ \"sqs\", \"sgn\" ], ssh: [ \"ssh\", \"ar\"  ], ssp: [ \"ssp\", \"sgn\" ],\n            ssr: [ \"ssr\", \"sgn\" ], svk: [ \"svk\", \"sgn\" ], swc: [ \"swc\", \"sw\"  ], swh: [ \"swh\", \"sw\"  ],\n            swl: [ \"swl\", \"sgn\" ], syy: [ \"syy\", \"sgn\" ], tmw: [ \"tmw\", \"ms\"  ], tse: [ \"tse\", \"sgn\" ],\n            tsm: [ \"tsm\", \"sgn\" ], tsq: [ \"tsq\", \"sgn\" ], tss: [ \"tss\", \"sgn\" ], tsy: [ \"tsy\", \"sgn\" ],\n            tza: [ \"tza\", \"sgn\" ], ugn: [ \"ugn\", \"sgn\" ], ugy: [ \"ugy\", \"sgn\" ], ukl: [ \"ukl\", \"sgn\" ],\n            uks: [ \"uks\", \"sgn\" ], urk: [ \"urk\", \"ms\"  ], uzn: [ \"uzn\", \"uz\"  ], uzs: [ \"uzs\", \"uz\"  ],\n            vgt: [ \"vgt\", \"sgn\" ], vkk: [ \"vkk\", \"ms\"  ], vkt: [ \"vkt\", \"ms\"  ], vsi: [ \"vsi\", \"sgn\" ],\n            vsl: [ \"vsl\", \"sgn\" ], vsv: [ \"vsv\", \"sgn\" ], wuu: [ \"wuu\", \"zh\"  ], xki: [ \"xki\", \"sgn\" ],\n            xml: [ \"xml\", \"sgn\" ], xmm: [ \"xmm\", \"ms\"  ], xms: [ \"xms\", \"sgn\" ], yds: [ \"yds\", \"sgn\" ],\n            ysl: [ \"ysl\", \"sgn\" ], yue: [ \"yue\", \"zh\"  ], zib: [ \"zib\", \"sgn\" ], zlm: [ \"zlm\", \"ms\"  ],\n            zmi: [ \"zmi\", \"ms\"  ], zsl: [ \"zsl\", \"sgn\" ], zsm: [ \"zsm\", \"ms\"  ]\n        }\n    },\n\n    // Currency minor units output from get-4217 grunt task, formatted\n    currencyMinorUnits = {\n        BHD: 3, BYR: 0, XOF: 0, BIF: 0, XAF: 0, CLF: 4, CLP: 0, KMF: 0, DJF: 0,\n        XPF: 0, GNF: 0, ISK: 0, IQD: 3, JPY: 0, JOD: 3, KRW: 0, KWD: 3, LYD: 3,\n        OMR: 3, PYG: 0, RWF: 0, TND: 3, UGX: 0, UYI: 0, VUV: 0, VND: 0\n    };\n\n// Sect 6.2 Language Tags\n// ======================\n\n/**\n * The IsStructurallyValidLanguageTag abstract operation verifies that the locale\n * argument (which must be a String value)\n *\n * - represents a well-formed BCP 47 language tag as specified in RFC 5646 section\n *   2.1, or successor,\n * - does not include duplicate variant subtags, and\n * - does not include duplicate singleton subtags.\n *\n * The abstract operation returns true if locale can be generated from the ABNF\n * grammar in section 2.1 of the RFC, starting with Language-Tag, and does not\n * contain duplicate variant or singleton subtags (other than as a private use\n * subtag). It returns false otherwise. Terminal value characters in the grammar are\n * interpreted as the Unicode equivalents of the ASCII octet values given.\n */\nfunction /* 6.2.2 */IsStructurallyValidLanguageTag(locale) {\n    // represents a well-formed BCP 47 language tag as specified in RFC 5646\n    if (!src$exp$$.expBCP47Syntax.test(locale))\n        return false;\n\n    // does not include duplicate variant subtags, and\n    if (src$exp$$.expVariantDupes.test(locale))\n        return false;\n\n    // does not include duplicate singleton subtags.\n    if (src$exp$$.expSingletonDupes.test(locale))\n        return false;\n\n    return true;\n}\n\n/**\n * The CanonicalizeLanguageTag abstract operation returns the canonical and case-\n * regularized form of the locale argument (which must be a String value that is\n * a structurally valid BCP 47 language tag as verified by the\n * IsStructurallyValidLanguageTag abstract operation). It takes the steps\n * specified in RFC 5646 section 4.5, or successor, to bring the language tag\n * into canonical form, and to regularize the case of the subtags, but does not\n * take the steps to bring a language tag into extlang form and to reorder\n * variant subtags.\n\n * The specifications for extensions to BCP 47 language tags, such as RFC 6067,\n * may include canonicalization rules for the extension subtag sequences they\n * define that go beyond the canonicalization rules of RFC 5646 section 4.5.\n * Implementations are allowed, but not required, to apply these additional rules.\n */\nfunction /* 6.2.3 */CanonicalizeLanguageTag (locale) {\n    var match, parts;\n\n    // A language tag is in 'canonical form' when the tag is well-formed\n    // according to the rules in Sections 2.1 and 2.2\n\n    // Section 2.1 says all subtags use lowercase...\n    locale = locale.toLowerCase();\n\n    // ...with 2 exceptions: 'two-letter and four-letter subtags that neither\n    // appear at the start of the tag nor occur after singletons.  Such two-letter\n    // subtags are all uppercase (as in the tags \"en-CA-x-ca\" or \"sgn-BE-FR\") and\n    // four-letter subtags are titlecase (as in the tag \"az-Latn-x-latn\").\n    parts = locale.split('-');\n    for (var i = 1, max = parts.length; i < max; i++) {\n        // Two-letter subtags are all uppercase\n        if (parts[i].length === 2)\n            parts[i] = parts[i].toUpperCase();\n\n        // Four-letter subtags are titlecase\n        else if (parts[i].length === 4)\n            parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].slice(1);\n\n        // Is it a singleton?\n        else if (parts[i].length === 1 && parts[i] !== 'x')\n            break;\n    }\n    locale = arrJoin.call(parts, '-');\n\n    // The steps laid out in RFC 5646 section 4.5 are as follows:\n\n    // 1.  Extension sequences are ordered into case-insensitive ASCII order\n    //     by singleton subtag.\n    if ((match = locale.match(src$exp$$.expExtSequences)) && match.length > 1) {\n        // The built-in sort() sorts by ASCII order, so use that\n        match.sort();\n\n        // Replace all extensions with the joined, sorted array\n        locale = locale.replace(\n            RegExp('(?:' + src$exp$$.expExtSequences.source + ')+', 'i'),\n            arrJoin.call(match, '')\n        );\n    }\n\n    // 2.  Redundant or grandfathered tags are replaced by their 'Preferred-\n    //     Value', if there is one.\n    if (hop.call(redundantTags.tags, locale))\n        locale = redundantTags.tags[locale];\n\n    // 3.  Subtags are replaced by their 'Preferred-Value', if there is one.\n    //     For extlangs, the original primary language subtag is also\n    //     replaced if there is a primary language subtag in the 'Preferred-\n    //     Value'.\n    parts = locale.split('-');\n\n    for (var i = 1, max = parts.length; i < max; i++) {\n        if (hop.call(redundantTags.subtags, parts[i]))\n            parts[i] = redundantTags.subtags[parts[i]];\n\n        else if (hop.call(redundantTags.extLang, parts[i])) {\n            parts[i] = redundantTags.extLang[parts[i]][0];\n\n            // For extlang tags, the prefix needs to be removed if it is redundant\n            if (i === 1 && redundantTags.extLang[parts[1]][1] === parts[0]) {\n                parts = arrSlice.call(parts, i++);\n                max -= 1;\n            }\n        }\n    }\n\n    return arrJoin.call(parts, '-');\n}\n\n/**\n * The DefaultLocale abstract operation returns a String value representing the\n * structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the\n * host environments current locale.\n */\nfunction /* 6.2.4 */DefaultLocale () {\n    return defaultLocale;\n}\n\n// Sect 6.3 Currency Codes\n// =======================\n\n/**\n * The IsWellFormedCurrencyCode abstract operation verifies that the currency argument\n * (after conversion to a String value) represents a well-formed 3-letter ISO currency\n * code. The following steps are taken:\n */\nfunction /* 6.3.1 */IsWellFormedCurrencyCode(currency) {\n    var\n        // 1. Let `c` be ToString(currency)\n        c = String(currency),\n\n        // 2. Let `normalized` be the result of mapping c to upper case as described\n        //    in 6.1.\n        normalized = toLatinUpperCase(c);\n\n    // 3. If the string length of normalized is not 3, return false.\n    // 4. If normalized contains any character that is not in the range \"A\" to \"Z\"\n    //    (U+0041 to U+005A), return false.\n    if (expCurrencyCode.test(normalized) === false)\n        return false;\n\n    // 5. Return true\n    return true;\n}\n\n// Sect 9.2 Abstract Operations\n// ============================\nfunction /* 9.2.1 */CanonicalizeLocaleList (locales) {\n// The abstract operation CanonicalizeLocaleList takes the following steps:\n\n    // 1. If locales is undefined, then a. Return a new empty List\n    if (locales === undefined)\n        return new List();\n\n    var\n        // 2. Let seen be a new empty List.\n        seen = new List(),\n\n        // 3. If locales is a String value, then\n        //    a. Let locales be a new array created as if by the expression new\n        //    Array(locales) where Array is the standard built-in constructor with\n        //    that name and locales is the value of locales.\n        locales = typeof locales === 'string' ? [ locales ] : locales,\n\n        // 4. Let O be ToObject(locales).\n        O = toObject(locales),\n\n        // 5. Let lenValue be the result of calling the [[Get]] internal method of\n        //    O with the argument \"length\".\n        // 6. Let len be ToUint32(lenValue).\n        len = O.length,\n\n        // 7. Let k be 0.\n        k = 0;\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n        var\n            // a. Let Pk be ToString(k).\n            Pk = String(k),\n\n            // b. Let kPresent be the result of calling the [[HasProperty]] internal\n            //    method of O with argument Pk.\n            kPresent = Pk in O;\n\n        // c. If kPresent is true, then\n        if (kPresent) {\n            var\n                // i. Let kValue be the result of calling the [[Get]] internal\n                //     method of O with argument Pk.\n                kValue = O[Pk];\n\n            // ii. If the type of kValue is not String or Object, then throw a\n            //     TypeError exception.\n            if (kValue == null || (typeof kValue !== 'string' && typeof kValue !== 'object'))\n                throw new TypeError('String or Object type expected');\n\n            var\n                // iii. Let tag be ToString(kValue).\n                tag = String(kValue);\n\n            // iv. If the result of calling the abstract operation\n            //     IsStructurallyValidLanguageTag (defined in 6.2.2), passing tag as\n            //     the argument, is false, then throw a RangeError exception.\n            if (!IsStructurallyValidLanguageTag(tag))\n                throw new RangeError(\"'\" + tag + \"' is not a structurally valid language tag\");\n\n            // v. Let tag be the result of calling the abstract operation\n            //    CanonicalizeLanguageTag (defined in 6.2.3), passing tag as the\n            //    argument.\n            tag = CanonicalizeLanguageTag(tag);\n\n            // vi. If tag is not an element of seen, then append tag as the last\n            //     element of seen.\n            if (arrIndexOf.call(seen, tag) === -1)\n                arrPush.call(seen, tag);\n        }\n\n        // d. Increase k by 1.\n        k++;\n    }\n\n    // 9. Return seen.\n    return seen;\n}\n\n/**\n * The BestAvailableLocale abstract operation compares the provided argument\n * locale, which must be a String value with a structurally valid and\n * canonicalized BCP 47 language tag, against the locales in availableLocales and\n * returns either the longest non-empty prefix of locale that is an element of\n * availableLocales, or undefined if there is no such element. It uses the\n * fallback mechanism of RFC 4647, section 3.4. The following steps are taken:\n */\nfunction /* 9.2.2 */BestAvailableLocale (availableLocales, locale) {\n    var\n       // 1. Let candidate be locale\n       candidate = locale;\n\n    // 2. Repeat\n    while (true) {\n        // a. If availableLocales contains an element equal to candidate, then return\n        // candidate.\n        if (arrIndexOf.call(availableLocales, candidate) > -1)\n            return candidate;\n\n        var\n            // b. Let pos be the character index of the last occurrence of \"-\"\n            // (U+002D) within candidate. If that character does not occur, return\n            // undefined.\n            pos = candidate.lastIndexOf('-');\n\n        if (pos < 0)\n            return;\n\n        // c. If pos  2 and the character \"-\" occurs at index pos-2 of candidate,\n        //    then decrease pos by 2.\n        if (pos >= 2 && candidate.charAt(pos - 2) === '-')\n            pos -= 2;\n\n        // d. Let candidate be the substring of candidate from position 0, inclusive,\n        //    to position pos, exclusive.\n        candidate = candidate.substring(0, pos);\n    }\n}\n\n/**\n * The LookupMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The following steps are taken:\n */\nfunction /* 9.2.3 */LookupMatcher (availableLocales, requestedLocales) {\n    var\n        // 1. Let i be 0.\n        i = 0,\n\n        // 2. Let len be the number of elements in requestedLocales.\n        len = requestedLocales.length,\n\n        // 3. Let availableLocale be undefined.\n        availableLocale;\n\n    // 4. Repeat while i < len and availableLocale is undefined:\n    while (i < len && !availableLocale) {\n        var\n            // a. Let locale be the element of requestedLocales at 0-origined list\n            //    position i.\n            locale = requestedLocales[i],\n\n            // b. Let noExtensionsLocale be the String value that is locale with all\n            //    Unicode locale extension sequences removed.\n            noExtensionsLocale = String(locale).replace(expUnicodeExSeq, ''),\n\n            // c. Let availableLocale be the result of calling the\n            //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n            //    arguments availableLocales and noExtensionsLocale.\n            availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\n        // d. Increase i by 1.\n        i++;\n    }\n\n    var\n        // 5. Let result be a new Record.\n        result = new Record();\n\n    // 6. If availableLocale is not undefined, then\n    if (availableLocale !== undefined) {\n        // a. Set result.[[locale]] to availableLocale.\n        result['[[locale]]'] = availableLocale;\n\n        // b. If locale and noExtensionsLocale are not the same String value, then\n        if (String(locale) !== String(noExtensionsLocale)) {\n            var\n                // i. Let extension be the String value consisting of the first\n                //    substring of locale that is a Unicode locale extension sequence.\n                extension = locale.match(expUnicodeExSeq)[0],\n\n                // ii. Let extensionIndex be the character position of the initial\n                //     \"-\" of the first Unicode locale extension sequence within locale.\n                extensionIndex = locale.indexOf('-u-');\n\n            // iii. Set result.[[extension]] to extension.\n            result['[[extension]]'] = extension;\n\n            // iv. Set result.[[extensionIndex]] to extensionIndex.\n            result['[[extensionIndex]]'] = extensionIndex;\n        }\n    }\n    // 7. Else\n    else\n        // a. Set result.[[locale]] to the value returned by the DefaultLocale abstract\n        //    operation (defined in 6.2.4).\n        result['[[locale]]'] = DefaultLocale();\n\n    // 8. Return result\n    return result;\n}\n\n/**\n * The BestFitMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The algorithm is implementation dependent, but should produce results\n * that a typical user of the requested locales would perceive as at least as\n * good as those produced by the LookupMatcher abstract operation. Options\n * specified through Unicode locale extension sequences must be ignored by the\n * algorithm. Information about such subsequences is returned separately.\n * The abstract operation returns a record with a [[locale]] field, whose value\n * is the language tag of the selected locale, which must be an element of\n * availableLocales. If the language tag of the request locale that led to the\n * selected locale contained a Unicode locale extension sequence, then the\n * returned record also contains an [[extension]] field whose value is the first\n * Unicode locale extension sequence, and an [[extensionIndex]] field whose value\n * is the index of the first Unicode locale extension sequence within the request\n * locale language tag.\n */\nfunction /* 9.2.4 */BestFitMatcher (availableLocales, requestedLocales) {\n    return LookupMatcher(availableLocales, requestedLocales);\n}\n\n/**\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\n * requestedLocales against the locales in availableLocales and determines the\n * best available language to meet the request. availableLocales and\n * requestedLocales must be provided as List values, options as a Record.\n */\nfunction /* 9.2.5 */ResolveLocale (availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {\n    if (availableLocales.length === 0) {\n        throw new ReferenceError('No locale data has been provided for this object yet.');\n    }\n\n    // The following steps are taken:\n    var\n        // 1. Let matcher be the value of options.[[localeMatcher]].\n        matcher = options['[[localeMatcher]]'];\n\n    // 2. If matcher is \"lookup\", then\n    if (matcher === 'lookup')\n        var\n            // a. Let r be the result of calling the LookupMatcher abstract operation\n            //    (defined in 9.2.3) with arguments availableLocales and\n            //    requestedLocales.\n            r = LookupMatcher(availableLocales, requestedLocales);\n\n    // 3. Else\n    else\n        var\n            // a. Let r be the result of calling the BestFitMatcher abstract\n            //    operation (defined in 9.2.4) with arguments availableLocales and\n            //    requestedLocales.\n            r = BestFitMatcher(availableLocales, requestedLocales);\n\n    var\n        // 4. Let foundLocale be the value of r.[[locale]].\n        foundLocale = r['[[locale]]'];\n\n    // 5. If r has an [[extension]] field, then\n    if (hop.call(r, '[[extension]]'))\n        var\n            // a. Let extension be the value of r.[[extension]].\n            extension = r['[[extension]]'],\n            // b. Let extensionIndex be the value of r.[[extensionIndex]].\n            extensionIndex = r['[[extensionIndex]]'],\n            // c. Let split be the standard built-in function object defined in ES5,\n            //    15.5.4.14.\n            split = String.prototype.split,\n            // d. Let extensionSubtags be the result of calling the [[Call]] internal\n            //    method of split with extension as the this value and an argument\n            //    list containing the single item \"-\".\n            extensionSubtags = split.call(extension, '-'),\n            // e. Let extensionSubtagsLength be the result of calling the [[Get]]\n            //    internal method of extensionSubtags with argument \"length\".\n            extensionSubtagsLength = extensionSubtags.length;\n\n    var\n        // 6. Let result be a new Record.\n        result = new Record();\n\n    // 7. Set result.[[dataLocale]] to foundLocale.\n    result['[[dataLocale]]'] = foundLocale;\n\n    var\n        // 8. Let supportedExtension be \"-u\".\n        supportedExtension = '-u',\n        // 9. Let i be 0.\n        i = 0,\n        // 10. Let len be the result of calling the [[Get]] internal method of\n        //     relevantExtensionKeys with argument \"length\".\n        len = relevantExtensionKeys.length;\n\n    // 11 Repeat while i < len:\n    while (i < len) {\n        var\n            // a. Let key be the result of calling the [[Get]] internal method of\n            //    relevantExtensionKeys with argument ToString(i).\n            key = relevantExtensionKeys[i],\n            // b. Let foundLocaleData be the result of calling the [[Get]] internal\n            //    method of localeData with the argument foundLocale.\n            foundLocaleData = localeData[foundLocale],\n            // c. Let keyLocaleData be the result of calling the [[Get]] internal\n            //    method of foundLocaleData with the argument key.\n            keyLocaleData = foundLocaleData[key],\n            // d. Let value be the result of calling the [[Get]] internal method of\n            //    keyLocaleData with argument \"0\".\n            value = keyLocaleData['0'],\n            // e. Let supportedExtensionAddition be \"\".\n            supportedExtensionAddition = '',\n            // f. Let indexOf be the standard built-in function object defined in\n            //    ES5, 15.4.4.14.\n            indexOf = arrIndexOf;\n\n        // g. If extensionSubtags is not undefined, then\n        if (extensionSubtags !== undefined) {\n            var\n                // i. Let keyPos be the result of calling the [[Call]] internal\n                //    method of indexOf with extensionSubtags as the this value and\n                // an argument list containing the single item key.\n                keyPos = indexOf.call(extensionSubtags, key);\n\n            // ii. If keyPos  -1, then\n            if (keyPos !== -1) {\n                // 1. If keyPos + 1 < extensionSubtagsLength and the length of the\n                //    result of calling the [[Get]] internal method of\n                //    extensionSubtags with argument ToString(keyPos +1) is greater\n                //    than 2, then\n                if (keyPos + 1 < extensionSubtagsLength\n                        && extensionSubtags[keyPos + 1].length > 2) {\n                    var\n                        // a. Let requestedValue be the result of calling the [[Get]]\n                        //    internal method of extensionSubtags with argument\n                        //    ToString(keyPos + 1).\n                        requestedValue = extensionSubtags[keyPos + 1],\n                        // b. Let valuePos be the result of calling the [[Call]]\n                        //    internal method of indexOf with keyLocaleData as the\n                        //    this value and an argument list containing the single\n                        //    item requestedValue.\n                        valuePos = indexOf.call(keyLocaleData, requestedValue);\n\n                    // c. If valuePos  -1, then\n                    if (valuePos !== -1)\n                        var\n                            // i. Let value be requestedValue.\n                            value = requestedValue,\n                            // ii. Let supportedExtensionAddition be the\n                            //     concatenation of \"-\", key, \"-\", and value.\n                            supportedExtensionAddition = '-' + key + '-' + value;\n                }\n                // 2. Else\n                else {\n                    var\n                        // a. Let valuePos be the result of calling the [[Call]]\n                        // internal method of indexOf with keyLocaleData as the this\n                        // value and an argument list containing the single item\n                        // \"true\".\n                        valuePos = indexOf(keyLocaleData, 'true');\n\n                    // b. If valuePos  -1, then\n                    if (valuePos !== -1)\n                        var\n                            // i. Let value be \"true\".\n                            value = 'true';\n                }\n            }\n        }\n        // h. If options has a field [[<key>]], then\n        if (hop.call(options, '[[' + key + ']]')) {\n            var\n                // i. Let optionsValue be the value of options.[[<key>]].\n                optionsValue = options['[[' + key + ']]'];\n\n            // ii. If the result of calling the [[Call]] internal method of indexOf\n            //     with keyLocaleData as the this value and an argument list\n            //     containing the single item optionsValue is not -1, then\n            if (indexOf.call(keyLocaleData, optionsValue) !== -1) {\n                // 1. If optionsValue is not equal to value, then\n                if (optionsValue !== value) {\n                    // a. Let value be optionsValue.\n                    value = optionsValue;\n                    // b. Let supportedExtensionAddition be \"\".\n                    supportedExtensionAddition = '';\n                }\n            }\n        }\n        // i. Set result.[[<key>]] to value.\n        result['[[' + key + ']]'] = value;\n\n        // j. Append supportedExtensionAddition to supportedExtension.\n        supportedExtension += supportedExtensionAddition;\n\n        // k. Increase i by 1.\n        i++;\n    }\n    // 12. If the length of supportedExtension is greater than 2, then\n    if (supportedExtension.length > 2) {\n        var\n            // a. Let preExtension be the substring of foundLocale from position 0,\n            //    inclusive, to position extensionIndex, exclusive.\n            preExtension = foundLocale.substring(0, extensionIndex),\n            // b. Let postExtension be the substring of foundLocale from position\n            //    extensionIndex to the end of the string.\n            postExtension = foundLocale.substring(extensionIndex),\n            // c. Let foundLocale be the concatenation of preExtension,\n            //    supportedExtension, and postExtension.\n            foundLocale = preExtension + supportedExtension + postExtension;\n    }\n    // 13. Set result.[[locale]] to foundLocale.\n    result['[[locale]]'] = foundLocale;\n\n    // 14. Return result.\n    return result;\n}\n\n/**\n * The LookupSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n * The following steps are taken:\n */\nfunction /* 9.2.6 */LookupSupportedLocales (availableLocales, requestedLocales) {\n    var\n        // 1. Let len be the number of elements in requestedLocales.\n        len = requestedLocales.length,\n        // 2. Let subset be a new empty List.\n        subset = new List(),\n        // 3. Let k be 0.\n        k = 0;\n\n    // 4. Repeat while k < len\n    while (k < len) {\n        var\n            // a. Let locale be the element of requestedLocales at 0-origined list\n            //    position k.\n            locale = requestedLocales[k],\n            // b. Let noExtensionsLocale be the String value that is locale with all\n            //    Unicode locale extension sequences removed.\n            noExtensionsLocale = String(locale).replace(expUnicodeExSeq, ''),\n            // c. Let availableLocale be the result of calling the\n            //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n            //    arguments availableLocales and noExtensionsLocale.\n            availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\n        // d. If availableLocale is not undefined, then append locale to the end of\n        //    subset.\n        if (availableLocale !== undefined)\n            arrPush.call(subset, locale);\n\n        // e. Increment k by 1.\n        k++;\n    }\n\n    var\n        // 5. Let subsetArray be a new Array object whose elements are the same\n        //    values in the same order as the elements of subset.\n        subsetArray = arrSlice.call(subset);\n\n    // 6. Return subsetArray.\n    return subsetArray;\n}\n\n/**\n * The BestFitSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the Best Fit Matcher\n * algorithm. Locales appear in the same order in the returned list as in\n * requestedLocales. The steps taken are implementation dependent.\n */\nfunction /*9.2.7 */BestFitSupportedLocales (availableLocales, requestedLocales) {\n    // ###TODO: implement this function as described by the specification###\n    return LookupSupportedLocales(availableLocales, requestedLocales);\n}\n\n/**\n * The SupportedLocales abstract operation returns the subset of the provided BCP\n * 47 language priority list requestedLocales for which availableLocales has a\n * matching locale. Two algorithms are available to match the locales: the Lookup\n * algorithm described in RFC 4647 section 3.4, and an implementation dependent\n * best-fit algorithm. Locales appear in the same order in the returned list as\n * in requestedLocales. The following steps are taken:\n */\nfunction /*9.2.8 */SupportedLocales (availableLocales, requestedLocales, options) {\n    // 1. If options is not undefined, then\n    if (options !== undefined) {\n        var\n            // a. Let options be ToObject(options).\n            options = new Record(toObject(options)),\n            // b. Let matcher be the result of calling the [[Get]] internal method of\n            //    options with argument \"localeMatcher\".\n            matcher = options.localeMatcher;\n\n        // c. If matcher is not undefined, then\n        if (matcher !== undefined) {\n            // i. Let matcher be ToString(matcher).\n            matcher = String(matcher);\n\n            // ii. If matcher is not \"lookup\" or \"best fit\", then throw a RangeError\n            //     exception.\n            if (matcher !== 'lookup' && matcher !== 'best fit')\n                throw new RangeError('matcher should be \"lookup\" or \"best fit\"');\n        }\n    }\n    // 2. If matcher is undefined or \"best fit\", then\n    if (matcher === undefined || matcher === 'best fit')\n        var\n            // a. Let subset be the result of calling the BestFitSupportedLocales\n            //    abstract operation (defined in 9.2.7) with arguments\n            //    availableLocales and requestedLocales.\n            subset = BestFitSupportedLocales(availableLocales, requestedLocales);\n    // 3. Else\n    else\n        var\n            // a. Let subset be the result of calling the LookupSupportedLocales\n            //    abstract operation (defined in 9.2.6) with arguments\n            //    availableLocales and requestedLocales.\n            subset = LookupSupportedLocales(availableLocales, requestedLocales);\n\n    // 4. For each named own property name P of subset,\n    for (var P in subset) {\n        if (!hop.call(subset, P))\n            continue;\n\n        // a. Let desc be the result of calling the [[GetOwnProperty]] internal\n        //    method of subset with P.\n        // b. Set desc.[[Writable]] to false.\n        // c. Set desc.[[Configurable]] to false.\n        // d. Call the [[DefineOwnProperty]] internal method of subset with P, desc,\n        //    and true as arguments.\n        defineProperty(subset, P, {\n            writable: false, configurable: false, value: subset[P]\n        });\n    }\n    // \"Freeze\" the array so no new elements can be added\n    defineProperty(subset, 'length', { writable: false });\n\n    // 5. Return subset\n    return subset;\n}\n\n/**\n * The GetOption abstract operation extracts the value of the property named\n * property from the provided options object, converts it to the required type,\n * checks whether it is one of a List of allowed values, and fills in a fallback\n * value if necessary.\n */\nfunction /*9.2.9 */GetOption (options, property, type, values, fallback) {\n    var\n        // 1. Let value be the result of calling the [[Get]] internal method of\n        //    options with argument property.\n        value = options[property];\n\n    // 2. If value is not undefined, then\n    if (value !== undefined) {\n        // a. Assert: type is \"boolean\" or \"string\".\n        // b. If type is \"boolean\", then let value be ToBoolean(value).\n        // c. If type is \"string\", then let value be ToString(value).\n        value = type === 'boolean' ? Boolean(value)\n                  : (type === 'string' ? String(value) : value);\n\n        // d. If values is not undefined, then\n        if (values !== undefined) {\n            // i. If values does not contain an element equal to value, then throw a\n            //    RangeError exception.\n            if (arrIndexOf.call(values, value) === -1)\n                throw new RangeError(\"'\" + value + \"' is not an allowed value for `\" + property +'`');\n        }\n\n        // e. Return value.\n        return value;\n    }\n    // Else return fallback.\n    return fallback;\n}\n\n/**\n * The GetNumberOption abstract operation extracts a property value from the\n * provided options object, converts it to a Number value, checks whether it is\n * in the allowed range, and fills in a fallback value if necessary.\n */\nfunction /* 9.2.10 */GetNumberOption (options, property, minimum, maximum, fallback) {\n    var\n        // 1. Let value be the result of calling the [[Get]] internal method of\n        //    options with argument property.\n        value = options[property];\n\n    // 2. If value is not undefined, then\n    if (value !== undefined) {\n        // a. Let value be ToNumber(value).\n        value = Number(value);\n\n        // b. If value is NaN or less than minimum or greater than maximum, throw a\n        //    RangeError exception.\n        if (isNaN(value) || value < minimum || value > maximum)\n            throw new RangeError('Value is not a number or outside accepted range');\n\n        // c. Return floor(value).\n        return Math.floor(value);\n    }\n    // 3. Else return fallback.\n    return fallback;\n}\n\n// 11.1 The Intl.NumberFormat constructor\n// ======================================\n\n// Define the NumberFormat constructor internally so it cannot be tainted\nfunction NumberFormatConstructor () {\n    var locales = arguments[0];\n    var options = arguments[1];\n\n    if (!this || this === Intl) {\n        return new Intl.NumberFormat(locales, options);\n    }\n\n    return InitializeNumberFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'NumberFormat', {\n    configurable: true,\n    writable: true,\n    value: NumberFormatConstructor\n});\n\n// Must explicitly set prototypes as unwritable\ndefineProperty(Intl.NumberFormat, 'prototype', {\n    writable: false\n});\n\n/**\n * The abstract operation InitializeNumberFormat accepts the arguments\n * numberFormat (which must be an object), locales, and options. It initializes\n * numberFormat as a NumberFormat object.\n */\nfunction /*11.1.1.1 */InitializeNumberFormat (numberFormat, locales, options) {\n    var\n    // This will be a internal properties object if we're not already initialized\n        internal = getInternalProperties(numberFormat),\n\n    // Create an object whose props can be used to restore the values of RegExp props\n        regexpState = createRegExpRestore();\n\n    // 1. If numberFormat has an [[initializedIntlObject]] internal property with\n    // value true, throw a TypeError exception.\n    if (internal['[[initializedIntlObject]]'] === true)\n        throw new TypeError('`this` object has already been initialized as an Intl object');\n\n    // Need this to access the `internal` object\n    defineProperty(numberFormat, '__getInternalProperties', {\n        value: function () {\n            // NOTE: Non-standard, for internal use only\n            if (arguments[0] === secret)\n                return internal;\n        }\n    });\n\n    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n    internal['[[initializedIntlObject]]'] = true;\n\n    var\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n        requestedLocales = CanonicalizeLocaleList(locales);\n\n    // 4. If options is undefined, then\n    if (options === undefined)\n        // a. Let options be the result of creating a new object as if by the\n        // expression new Object() where Object is the standard built-in constructor\n        // with that name.\n        options = {};\n\n    // 5. Else\n    else\n        // a. Let options be ToObject(options).\n        options = toObject(options);\n\n    var\n    // 6. Let opt be a new Record.\n        opt = new Record(),\n\n    // 7. Let matcher be the result of calling the GetOption abstract operation\n    //    (defined in 9.2.9) with the arguments options, \"localeMatcher\", \"string\",\n    //    a List containing the two String values \"lookup\" and \"best fit\", and\n    //    \"best fit\".\n        matcher =  GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\n    // 8. Set opt.[[localeMatcher]] to matcher.\n    opt['[[localeMatcher]]'] = matcher;\n\n    var\n    // 9. Let NumberFormat be the standard built-in object that is the initial value\n    //    of Intl.NumberFormat.\n    // 10. Let localeData be the value of the [[localeData]] internal property of\n    //     NumberFormat.\n        localeData = internals.NumberFormat['[[localeData]]'],\n\n    // 11. Let r be the result of calling the ResolveLocale abstract operation\n    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n    //     NumberFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n    //     internal property of NumberFormat, and localeData.\n        r = ResolveLocale(\n                internals.NumberFormat['[[availableLocales]]'], requestedLocales,\n                opt, internals.NumberFormat['[[relevantExtensionKeys]]'], localeData\n            );\n\n    // 12. Set the [[locale]] internal property of numberFormat to the value of\n    //     r.[[locale]].\n    internal['[[locale]]'] = r['[[locale]]'];\n\n    // 13. Set the [[numberingSystem]] internal property of numberFormat to the value\n    //     of r.[[nu]].\n    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\n    // The specification doesn't tell us to do this, but it's helpful later on\n    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\n    var\n    // 14. Let dataLocale be the value of r.[[dataLocale]].\n        dataLocale = r['[[dataLocale]]'],\n\n    // 15. Let s be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"style\", \"string\", a List containing the three String\n    //     values \"decimal\", \"percent\", and \"currency\", and \"decimal\".\n        s = GetOption(options, 'style', 'string', new List('decimal', 'percent', 'currency'), 'decimal');\n\n    // 16. Set the [[style]] internal property of numberFormat to s.\n    internal['[[style]]'] = s;\n\n    var\n    // 17. Let c be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"currency\", \"string\", undefined, and undefined.\n        c = GetOption(options, 'currency', 'string');\n\n    // 18. If c is not undefined and the result of calling the\n    //     IsWellFormedCurrencyCode abstract operation (defined in 6.3.1) with\n    //     argument c is false, then throw a RangeError exception.\n    if (c !== undefined && !IsWellFormedCurrencyCode(c))\n        throw new RangeError(\"'\" + c + \"' is not a valid currency code\");\n\n    // 19. If s is \"currency\" and c is undefined, throw a TypeError exception.\n    if (s === 'currency' && c === undefined)\n        throw new TypeError('Currency code is required when style is currency');\n\n    // 20. If s is \"currency\", then\n    if (s === 'currency') {\n        // a. Let c be the result of converting c to upper case as specified in 6.1.\n        c = c.toUpperCase();\n\n        // b. Set the [[currency]] internal property of numberFormat to c.\n        internal['[[currency]]'] = c;\n\n        var\n        // c. Let cDigits be the result of calling the CurrencyDigits abstract\n        //    operation (defined below) with argument c.\n            cDigits = CurrencyDigits(c);\n    }\n\n    var\n    // 21. Let cd be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"currencyDisplay\", \"string\", a List containing the\n    //     three String values \"code\", \"symbol\", and \"name\", and \"symbol\".\n        cd = GetOption(options, 'currencyDisplay', 'string', new List('code', 'symbol', 'name'), 'symbol');\n\n    // 22. If s is \"currency\", then set the [[currencyDisplay]] internal property of\n    //     numberFormat to cd.\n    if (s === 'currency')\n        internal['[[currencyDisplay]]'] = cd;\n\n    var\n    // 23. Let mnid be the result of calling the GetNumberOption abstract operation\n    //     (defined in 9.2.10) with arguments options, \"minimumIntegerDigits\", 1, 21,\n    //     and 1.\n        mnid = GetNumberOption(options, 'minimumIntegerDigits', 1, 21, 1);\n\n    // 24. Set the [[minimumIntegerDigits]] internal property of numberFormat to mnid.\n    internal['[[minimumIntegerDigits]]'] = mnid;\n\n    var\n    // 25. If s is \"currency\", then let mnfdDefault be cDigits; else let mnfdDefault\n    //     be 0.\n        mnfdDefault = s === 'currency' ? cDigits : 0,\n\n    // 26. Let mnfd be the result of calling the GetNumberOption abstract operation\n    //     with arguments options, \"minimumFractionDigits\", 0, 20, and mnfdDefault.\n        mnfd = GetNumberOption(options, 'minimumFractionDigits', 0, 20, mnfdDefault);\n\n    // 27. Set the [[minimumFractionDigits]] internal property of numberFormat to mnfd.\n    internal['[[minimumFractionDigits]]'] = mnfd;\n\n    var\n    // 28. If s is \"currency\", then let mxfdDefault be max(mnfd, cDigits); else if s\n    //     is \"percent\", then let mxfdDefault be max(mnfd, 0); else let mxfdDefault\n    //     be max(mnfd, 3).\n        mxfdDefault = s === 'currency' ? Math.max(mnfd, cDigits)\n                    : (s === 'percent' ? Math.max(mnfd, 0) : Math.max(mnfd, 3)),\n\n    // 29. Let mxfd be the result of calling the GetNumberOption abstract operation\n    //     with arguments options, \"maximumFractionDigits\", mnfd, 20, and mxfdDefault.\n        mxfd = GetNumberOption(options, 'maximumFractionDigits', mnfd, 20, mxfdDefault);\n\n    // 30. Set the [[maximumFractionDigits]] internal property of numberFormat to mxfd.\n    internal['[[maximumFractionDigits]]'] = mxfd;\n\n    var\n    // 31. Let mnsd be the result of calling the [[Get]] internal method of options\n    //     with argument \"minimumSignificantDigits\".\n        mnsd = options.minimumSignificantDigits,\n\n    // 32. Let mxsd be the result of calling the [[Get]] internal method of options\n    //     with argument \"maximumSignificantDigits\".\n        mxsd = options.maximumSignificantDigits;\n\n    // 33. If mnsd is not undefined or mxsd is not undefined, then:\n    if (mnsd !== undefined || mxsd !== undefined) {\n        // a. Let mnsd be the result of calling the GetNumberOption abstract\n        //    operation with arguments options, \"minimumSignificantDigits\", 1, 21,\n        //    and 1.\n        mnsd = GetNumberOption(options, 'minimumSignificantDigits', 1, 21, 1);\n\n        // b. Let mxsd be the result of calling the GetNumberOption abstract\n        //     operation with arguments options, \"maximumSignificantDigits\", mnsd,\n        //     21, and 21.\n        mxsd = GetNumberOption(options, 'maximumSignificantDigits', mnsd, 21, 21);\n\n        // c. Set the [[minimumSignificantDigits]] internal property of numberFormat\n        //    to mnsd, and the [[maximumSignificantDigits]] internal property of\n        //    numberFormat to mxsd.\n        internal['[[minimumSignificantDigits]]'] = mnsd;\n        internal['[[maximumSignificantDigits]]'] = mxsd;\n    }\n    var\n    // 34. Let g be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"useGrouping\", \"boolean\", undefined, and true.\n        g = GetOption(options, 'useGrouping', 'boolean', undefined, true);\n\n    // 35. Set the [[useGrouping]] internal property of numberFormat to g.\n    internal['[[useGrouping]]'] = g;\n\n    var\n    // 36. Let dataLocaleData be the result of calling the [[Get]] internal method of\n    //     localeData with argument dataLocale.\n        dataLocaleData = localeData[dataLocale],\n\n    // 37. Let patterns be the result of calling the [[Get]] internal method of\n    //     dataLocaleData with argument \"patterns\".\n        patterns = dataLocaleData.patterns;\n\n    // 38. Assert: patterns is an object (see 11.2.3)\n\n    var\n    // 39. Let stylePatterns be the result of calling the [[Get]] internal method of\n    //     patterns with argument s.\n        stylePatterns = patterns[s];\n\n    // 40. Set the [[positivePattern]] internal property of numberFormat to the\n    //     result of calling the [[Get]] internal method of stylePatterns with the\n    //     argument \"positivePattern\".\n    internal['[[positivePattern]]'] = stylePatterns.positivePattern;\n\n    // 41. Set the [[negativePattern]] internal property of numberFormat to the\n    //     result of calling the [[Get]] internal method of stylePatterns with the\n    //     argument \"negativePattern\".\n    internal['[[negativePattern]]'] = stylePatterns.negativePattern;\n\n    // 42. Set the [[boundFormat]] internal property of numberFormat to undefined.\n    internal['[[boundFormat]]'] = undefined;\n\n    // 43. Set the [[initializedNumberFormat]] internal property of numberFormat to\n    //     true.\n    internal['[[initializedNumberFormat]]'] = true;\n\n    // In ES3, we need to pre-bind the format() function\n    if (es3)\n        numberFormat.format = GetFormatNumber.call(numberFormat);\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // Return the newly initialised object\n    return numberFormat;\n}\n\nfunction CurrencyDigits(currency) {\n    // When the CurrencyDigits abstract operation is called with an argument currency\n    // (which must be an upper case String value), the following steps are taken:\n\n    // 1. If the ISO 4217 currency and funds code list contains currency as an\n    // alphabetic code, then return the minor unit value corresponding to the\n    // currency from the list; else return 2.\n    return currencyMinorUnits[currency] !== undefined\n                ? currencyMinorUnits[currency]\n                : 2;\n}\n\n/* 11.2.3 */internals.NumberFormat = {\n    '[[availableLocales]]': [],\n    '[[relevantExtensionKeys]]': ['nu'],\n    '[[localeData]]': {}\n};\n\n/**\n * When the supportedLocalesOf method of Intl.NumberFormat is called, the\n * following steps are taken:\n */\n/* 11.2.2 */defineProperty(Intl.NumberFormat, 'supportedLocalesOf', {\n    configurable: true,\n    writable: true,\n    value: fnBind.call(supportedLocalesOf, internals.NumberFormat)\n});\n\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * NumberFormat object.\n */\n/* 11.3.2 */defineProperty(Intl.NumberFormat.prototype, 'format', {\n    configurable: true,\n    get: GetFormatNumber\n});\n\nfunction GetFormatNumber() {\n        var internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\n        // Satisfy test 11.3_b\n        if (!internal || !internal['[[initializedNumberFormat]]'])\n            throw new TypeError('`this` value for format() is not an initialized Intl.NumberFormat object.');\n\n        // The value of the [[Get]] attribute is a function that takes the following\n        // steps:\n\n        // 1. If the [[boundFormat]] internal property of this NumberFormat object\n        //    is undefined, then:\n        if (internal['[[boundFormat]]'] === undefined) {\n            var\n            // a. Let F be a Function object, with internal properties set as\n            //    specified for built-in functions in ES5, 15, or successor, and the\n            //    length property set to 1, that takes the argument value and\n            //    performs the following steps:\n                F = function (value) {\n                    // i. If value is not provided, then let value be undefined.\n                    // ii. Let x be ToNumber(value).\n                    // iii. Return the result of calling the FormatNumber abstract\n                    //      operation (defined below) with arguments this and x.\n                    return FormatNumber(this, /* x = */Number(value));\n                },\n\n            // b. Let bind be the standard built-in function object defined in ES5,\n            //    15.3.4.5.\n            // c. Let bf be the result of calling the [[Call]] internal method of\n            //    bind with F as the this value and an argument list containing\n            //    the single item this.\n                bf = fnBind.call(F, this);\n\n            // d. Set the [[boundFormat]] internal property of this NumberFormat\n            //    object to bf.\n            internal['[[boundFormat]]'] = bf;\n        }\n        // Return the value of the [[boundFormat]] internal property of this\n        // NumberFormat object.\n        return internal['[[boundFormat]]'];\n    }\n\n/**\n * When the FormatNumber abstract operation is called with arguments numberFormat\n * (which must be an object initialized as a NumberFormat) and x (which must be a\n * Number value), it returns a String value representing x according to the\n * effective locale and the formatting options of numberFormat.\n */\nfunction FormatNumber (numberFormat, x) {\n    var n,\n\n    // Create an object whose props can be used to restore the values of RegExp props\n        regexpState = createRegExpRestore(),\n\n        internal = getInternalProperties(numberFormat),\n        locale = internal['[[dataLocale]]'],\n        nums   = internal['[[numberingSystem]]'],\n        data   = internals.NumberFormat['[[localeData]]'][locale],\n        ild    = data.symbols[nums] || data.symbols.latn,\n\n    // 1. Let negative be false.\n        negative = false;\n\n    // 2. If the result of isFinite(x) is false, then\n    if (isFinite(x) === false) {\n        // a. If x is NaN, then let n be an ILD String value indicating the NaN value.\n        if (isNaN(x))\n            n = ild.nan;\n\n        // b. Else\n        else {\n            // a. Let n be an ILD String value indicating infinity.\n            n = ild.infinity;\n            // b. If x < 0, then let negative be true.\n            if (x < 0)\n                negative = true;\n        }\n    }\n    // 3. Else\n    else {\n        // a. If x < 0, then\n        if (x < 0) {\n            // i. Let negative be true.\n            negative = true;\n            // ii. Let x be -x.\n            x = -x;\n        }\n\n        // b. If the value of the [[style]] internal property of numberFormat is\n        //    \"percent\", let x be 100  x.\n        if (internal['[[style]]'] === 'percent')\n            x *= 100;\n\n        // c. If the [[minimumSignificantDigits]] and [[maximumSignificantDigits]]\n        //    internal properties of numberFormat are present, then\n        if (hop.call(internal, '[[minimumSignificantDigits]]') &&\n                hop.call(internal, '[[maximumSignificantDigits]]'))\n            // i. Let n be the result of calling the ToRawPrecision abstract operation\n            //    (defined below), passing as arguments x and the values of the\n            //    [[minimumSignificantDigits]] and [[maximumSignificantDigits]]\n            //    internal properties of numberFormat.\n            n = ToRawPrecision(x,\n                  internal['[[minimumSignificantDigits]]'],\n                  internal['[[maximumSignificantDigits]]']);\n        // d. Else\n        else\n            // i. Let n be the result of calling the ToRawFixed abstract operation\n            //    (defined below), passing as arguments x and the values of the\n            //    [[minimumIntegerDigits]], [[minimumFractionDigits]], and\n            //    [[maximumFractionDigits]] internal properties of numberFormat.\n            n = ToRawFixed(x,\n                  internal['[[minimumIntegerDigits]]'],\n                  internal['[[minimumFractionDigits]]'],\n                  internal['[[maximumFractionDigits]]']);\n\n        // e. If the value of the [[numberingSystem]] internal property of\n        //    numberFormat matches one of the values in the Numbering System column\n        //    of Table 2 below, then\n        if (numSys[nums]) {\n            // i. Let digits be an array whose 10 String valued elements are the\n            //    UTF-16 string representations of the 10 digits specified in the\n            //    Digits column of Table 2 in the row containing the value of the\n            //    [[numberingSystem]] internal property.\n            var digits = numSys[internal['[[numberingSystem]]']];\n            // ii. Replace each digit in n with the value of digits[digit].\n            n = String(n).replace(/\\d/g, function (digit) {\n                return digits[digit];\n            });\n        }\n        // f. Else use an implementation dependent algorithm to map n to the\n        //    appropriate representation of n in the given numbering system.\n        else\n            n = String(n); // ###TODO###\n\n        // g. If n contains the character \".\", then replace it with an ILND String\n        //    representing the decimal separator.\n        n = n.replace(/\\./g, ild.decimal);\n\n        // h. If the value of the [[useGrouping]] internal property of numberFormat\n        //    is true, then insert an ILND String representing a grouping separator\n        //    into an ILND set of locations within the integer part of n.\n        if (internal['[[useGrouping]]'] === true) {\n            var\n                parts  = n.split(ild.decimal),\n                igr    = parts[0],\n\n                // Primary group represents the group closest to the decimal\n                pgSize = data.patterns.primaryGroupSize || 3,\n\n                // Secondary group is every other group\n                sgSize = data.patterns.secondaryGroupSize || pgSize;\n\n            // Group only if necessary\n            if (igr.length > pgSize) {\n                var\n                    groups = new List(),\n\n                    // Index of the primary grouping separator\n                    end    = igr.length - pgSize,\n\n                    // Starting index for our loop\n                    idx    = end % sgSize,\n\n                    start  = igr.slice(0, idx);\n\n                if (start.length)\n                    arrPush.call(groups, start);\n\n                // Loop to separate into secondary grouping digits\n                while (idx < end) {\n                    arrPush.call(groups, igr.slice(idx, idx + sgSize));\n                    idx += sgSize;\n                }\n\n                // Add the primary grouping digits\n                arrPush.call(groups, igr.slice(end));\n\n                parts[0] = arrJoin.call(groups, ild.group);\n            }\n\n            n = arrJoin.call(parts, ild.decimal);\n        }\n    }\n\n    var\n    // 4. If negative is true, then let result be the value of the [[negativePattern]]\n    //    internal property of numberFormat; else let result be the value of the\n    //    [[positivePattern]] internal property of numberFormat.\n        result = internal[negative === true ? '[[negativePattern]]' : '[[positivePattern]]'];\n\n    // 5. Replace the substring \"{number}\" within result with n.\n    result = result.replace('{number}', n);\n\n    // 6. If the value of the [[style]] internal property of numberFormat is\n    //    \"currency\", then:\n    if (internal['[[style]]'] === 'currency') {\n        var cd,\n        // a. Let currency be the value of the [[currency]] internal property of\n        //    numberFormat.\n            currency = internal['[[currency]]'],\n\n        // Shorthand for the currency data\n            cData = data.currencies[currency];\n\n        // b. If the value of the [[currencyDisplay]] internal property of\n        //    numberFormat is \"code\", then let cd be currency.\n        // c. Else if the value of the [[currencyDisplay]] internal property of\n        //    numberFormat is \"symbol\", then let cd be an ILD string representing\n        //    currency in short form. If the implementation does not have such a\n        //    representation of currency, then use currency itself.\n        // d. Else if the value of the [[currencyDisplay]] internal property of\n        //    numberFormat is \"name\", then let cd be an ILD string representing\n        //    currency in long form. If the implementation does not have such a\n        //    representation of currency, then use currency itself.\n        switch (internal['[[currencyDisplay]]']) {\n            case 'symbol':\n                cd = cData || currency;\n                break;\n\n            default:\n            case 'code':\n            case 'name':\n                cd = currency;\n        }\n\n        // e. Replace the substring \"{currency}\" within result with cd.\n        result = result.replace('{currency}', cd);\n    }\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // 7. Return result.\n    return result;\n}\n\n/**\n * When the ToRawPrecision abstract operation is called with arguments x (which\n * must be a finite non-negative number), minPrecision, and maxPrecision (both\n * must be integers between 1 and 21) the following steps are taken:\n */\nfunction ToRawPrecision (x, minPrecision, maxPrecision) {\n    var\n    // 1. Let p be maxPrecision.\n        p = maxPrecision;\n\n    // 2. If x = 0, then\n    if (x === 0) {\n        var\n        // a. Let m be the String consisting of p occurrences of the character \"0\".\n            m = arrJoin.call(Array (p + 1), '0'),\n        // b. Let e be 0.\n            e = 0;\n    }\n    // 3. Else\n    else {\n        // a. Let e and n be integers such that 10  n < 10 and for which the\n        //    exact mathematical value of n  10  x is as close to zero as\n        //    possible. If there are two such sets of e and n, pick the e and n for\n        //    which n  10 is larger.\n        var\n            e = log10Floor(Math.abs(x)),\n\n            // Easier to get to m from here\n            f = Math.round(Math.exp((Math.abs(e - p + 1)) * Math.LN10)),\n\n        // b. Let m be the String consisting of the digits of the decimal\n        //    representation of n (in order, with no leading zeroes)\n            m = String(Math.round(e - p + 1 < 0 ? x * f : x / f));\n    }\n\n    // 4. If e  p, then\n    if (e >= p)\n        // a. Return the concatenation of m and e-p+1 occurrences of the character \"0\".\n        return m + arrJoin.call(Array(e-p+1 + 1), '0');\n\n    // 5. If e = p-1, then\n    else if (e === p - 1)\n        // a. Return m.\n        return m;\n\n    // 6. If e  0, then\n    else if (e >= 0)\n        // a. Let m be the concatenation of the first e+1 characters of m, the character\n        //    \".\", and the remaining p(e+1) characters of m.\n        m = m.slice(0, e + 1) + '.' + m.slice(e + 1);\n\n    // 7. If e < 0, then\n    else if (e < 0)\n        // a. Let m be the concatenation of the String \"0.\", (e+1) occurrences of the\n        //    character \"0\", and the string m.\n        m = '0.' + arrJoin.call(Array (-(e+1) + 1), '0') + m;\n\n    // 8. If m contains the character \".\", and maxPrecision > minPrecision, then\n    if (m.indexOf(\".\") >= 0 && maxPrecision > minPrecision) {\n        var\n        // a. Let cut be maxPrecision  minPrecision.\n            cut = maxPrecision - minPrecision;\n\n        // b. Repeat while cut > 0 and the last character of m is \"0\":\n        while (cut > 0 && m.charAt(m.length-1) === '0') {\n            //  i. Remove the last character from m.\n            m = m.slice(0, -1);\n\n            //  ii. Decrease cut by 1.\n            cut--;\n        }\n\n        // c. If the last character of m is \".\", then\n        if (m.charAt(m.length-1) === '.')\n            //    i. Remove the last character from m.\n            m = m.slice(0, -1);\n    }\n    // 9. Return m.\n    return m;\n}\n\n/**\n * When the ToRawFixed abstract operation is called with arguments x (which must\n * be a finite non-negative number), minInteger (which must be an integer between\n * 1 and 21), minFraction, and maxFraction (which must be integers between 0 and\n * 20) the following steps are taken:\n */\nfunction ToRawFixed (x, minInteger, minFraction, maxFraction) {\n    // (or not because Number.toPrototype.toFixed does a lot of it for us)\n    var idx,\n\n        // We can pick up after the fixed formatted string (m) is created\n        m   = Number.prototype.toFixed.call(x, maxFraction),\n\n        // 4. If [maxFraction]  0, then\n        //    ...\n        //    e. Let int be the number of characters in a.\n        //\n        // 5. Else let int be the number of characters in m.\n        igr = m.split(\".\")[0].length,  // int is a reserved word\n\n        // 6. Let cut be maxFraction  minFraction.\n        cut = maxFraction - minFraction,\n\n        exp = (idx = m.indexOf('e')) > -1 ? m.slice(idx + 1) : 0;\n\n    if (exp) {\n        m = m.slice(0, idx).replace('.', '');\n        m += arrJoin.call(Array(exp - (m.length - 1) + 1), '0')\n          + '.' + arrJoin.call(Array(maxFraction + 1), '0');\n\n        igr = m.length;\n    }\n\n    // 7. Repeat while cut > 0 and the last character of m is \"0\":\n    while (cut > 0 && m.slice(-1) === \"0\") {\n        // a. Remove the last character from m.\n        m = m.slice(0, -1);\n\n        // b. Decrease cut by 1.\n        cut--;\n    }\n\n    // 8. If the last character of m is \".\", then\n    if (m.slice(-1) === \".\")\n        // a. Remove the last character from m.\n        m = m.slice(0, -1);\n\n    // 9. If int < minInteger, then\n    if (igr < minInteger)\n        // a. Let z be the String consisting of minIntegerint occurrences of the\n        //    character \"0\".\n        var z = arrJoin.call(Array(minInteger - igr + 1), '0');\n\n    // 10. Let m be the concatenation of Strings z and m.\n    // 11. Return m.\n    return (z ? z : '') + m;\n}\n\n// Sect 11.3.2 Table 2, Numbering systems\n// ======================================\nvar numSys = {\n    arab:    [ '\\u0660', '\\u0661', '\\u0662', '\\u0663', '\\u0664', '\\u0665', '\\u0666', '\\u0667', '\\u0668', '\\u0669' ],\n    arabext: [ '\\u06F0', '\\u06F1', '\\u06F2', '\\u06F3', '\\u06F4', '\\u06F5', '\\u06F6', '\\u06F7', '\\u06F8', '\\u06F9' ],\n    bali:    [ '\\u1B50', '\\u1B51', '\\u1B52', '\\u1B53', '\\u1B54', '\\u1B55', '\\u1B56', '\\u1B57', '\\u1B58', '\\u1B59' ],\n    beng:    [ '\\u09E6', '\\u09E7', '\\u09E8', '\\u09E9', '\\u09EA', '\\u09EB', '\\u09EC', '\\u09ED', '\\u09EE', '\\u09EF' ],\n    deva:    [ '\\u0966', '\\u0967', '\\u0968', '\\u0969', '\\u096A', '\\u096B', '\\u096C', '\\u096D', '\\u096E', '\\u096F' ],\n    fullwide:[ '\\uFF10', '\\uFF11', '\\uFF12', '\\uFF13', '\\uFF14', '\\uFF15', '\\uFF16', '\\uFF17', '\\uFF18', '\\uFF19' ],\n    gujr:    [ '\\u0AE6', '\\u0AE7', '\\u0AE8', '\\u0AE9', '\\u0AEA', '\\u0AEB', '\\u0AEC', '\\u0AED', '\\u0AEE', '\\u0AEF' ],\n    guru:    [ '\\u0A66', '\\u0A67', '\\u0A68', '\\u0A69', '\\u0A6A', '\\u0A6B', '\\u0A6C', '\\u0A6D', '\\u0A6E', '\\u0A6F' ],\n    hanidec: [ '\\u3007', '\\u4E00', '\\u4E8C', '\\u4E09', '\\u56DB', '\\u4E94', '\\u516D', '\\u4E03', '\\u516B', '\\u4E5D' ],\n    khmr:    [ '\\u17E0', '\\u17E1', '\\u17E2', '\\u17E3', '\\u17E4', '\\u17E5', '\\u17E6', '\\u17E7', '\\u17E8', '\\u17E9' ],\n    knda:    [ '\\u0CE6', '\\u0CE7', '\\u0CE8', '\\u0CE9', '\\u0CEA', '\\u0CEB', '\\u0CEC', '\\u0CED', '\\u0CEE', '\\u0CEF' ],\n    laoo:    [ '\\u0ED0', '\\u0ED1', '\\u0ED2', '\\u0ED3', '\\u0ED4', '\\u0ED5', '\\u0ED6', '\\u0ED7', '\\u0ED8', '\\u0ED9' ],\n    latn:    [ '\\u0030', '\\u0031', '\\u0032', '\\u0033', '\\u0034', '\\u0035', '\\u0036', '\\u0037', '\\u0038', '\\u0039' ],\n    limb:    [ '\\u1946', '\\u1947', '\\u1948', '\\u1949', '\\u194A', '\\u194B', '\\u194C', '\\u194D', '\\u194E', '\\u194F' ],\n    mlym:    [ '\\u0D66', '\\u0D67', '\\u0D68', '\\u0D69', '\\u0D6A', '\\u0D6B', '\\u0D6C', '\\u0D6D', '\\u0D6E', '\\u0D6F' ],\n    mong:    [ '\\u1810', '\\u1811', '\\u1812', '\\u1813', '\\u1814', '\\u1815', '\\u1816', '\\u1817', '\\u1818', '\\u1819' ],\n    mymr:    [ '\\u1040', '\\u1041', '\\u1042', '\\u1043', '\\u1044', '\\u1045', '\\u1046', '\\u1047', '\\u1048', '\\u1049' ],\n    orya:    [ '\\u0B66', '\\u0B67', '\\u0B68', '\\u0B69', '\\u0B6A', '\\u0B6B', '\\u0B6C', '\\u0B6D', '\\u0B6E', '\\u0B6F' ],\n    tamldec: [ '\\u0BE6', '\\u0BE7', '\\u0BE8', '\\u0BE9', '\\u0BEA', '\\u0BEB', '\\u0BEC', '\\u0BED', '\\u0BEE', '\\u0BEF' ],\n    telu:    [ '\\u0C66', '\\u0C67', '\\u0C68', '\\u0C69', '\\u0C6A', '\\u0C6B', '\\u0C6C', '\\u0C6D', '\\u0C6E', '\\u0C6F' ],\n    thai:    [ '\\u0E50', '\\u0E51', '\\u0E52', '\\u0E53', '\\u0E54', '\\u0E55', '\\u0E56', '\\u0E57', '\\u0E58', '\\u0E59' ],\n    tibt:    [ '\\u0F20', '\\u0F21', '\\u0F22', '\\u0F23', '\\u0F24', '\\u0F25', '\\u0F26', '\\u0F27', '\\u0F28', '\\u0F29' ]\n};\n\n/**\n * This function provides access to the locale and formatting options computed\n * during initialization of the object.\n *\n * The function returns a new object whose properties and attributes are set as\n * if constructed by an object literal assigning to each of the following\n * properties the value of the corresponding internal property of this\n * NumberFormat object (see 11.4): locale, numberingSystem, style, currency,\n * currencyDisplay, minimumIntegerDigits, minimumFractionDigits,\n * maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, and\n * useGrouping. Properties whose corresponding internal properties are not present\n * are not assigned.\n */\n/* 11.3.3 */defineProperty(Intl.NumberFormat.prototype, 'resolvedOptions', {\n    configurable: true,\n    writable: true,\n    value: function () {\n        var prop,\n            descs = new Record(),\n            props = [\n                'locale', 'numberingSystem', 'style', 'currency', 'currencyDisplay',\n                'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits',\n                'minimumSignificantDigits', 'maximumSignificantDigits', 'useGrouping'\n            ],\n            internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\n        // Satisfy test 11.3_b\n        if (!internal || !internal['[[initializedNumberFormat]]'])\n            throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.NumberFormat object.');\n\n        for (var i = 0, max = props.length; i < max; i++) {\n            if (hop.call(internal, prop = '[['+ props[i] +']]'))\n                descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n        }\n\n        return objCreate({}, descs);\n    }\n});\n\n// 12.1 The Intl.DateTimeFormat constructor\n// ==================================\n\n// Define the DateTimeFormat constructor internally so it cannot be tainted\nfunction DateTimeFormatConstructor () {\n    var locales = arguments[0];\n    var options = arguments[1];\n\n    if (!this || this === Intl) {\n        return new Intl.DateTimeFormat(locales, options);\n    }\n    return InitializeDateTimeFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'DateTimeFormat', {\n    configurable: true,\n    writable: true,\n    value: DateTimeFormatConstructor\n});\n\n// Must explicitly set prototypes as unwritable\ndefineProperty(DateTimeFormatConstructor, 'prototype', {\n    writable: false\n});\n\n/**\n * The abstract operation InitializeDateTimeFormat accepts the arguments dateTimeFormat\n * (which must be an object), locales, and options. It initializes dateTimeFormat as a\n * DateTimeFormat object.\n */\nfunction/* 12.1.1.1 */InitializeDateTimeFormat (dateTimeFormat, locales, options) {\n    var\n    // This will be a internal properties object if we're not already initialized\n        internal = getInternalProperties(dateTimeFormat),\n\n    // Create an object whose props can be used to restore the values of RegExp props\n        regexpState = createRegExpRestore();\n\n    // 1. If dateTimeFormat has an [[initializedIntlObject]] internal property with\n    //    value true, throw a TypeError exception.\n    if (internal['[[initializedIntlObject]]'] === true)\n        throw new TypeError('`this` object has already been initialized as an Intl object');\n\n    // Need this to access the `internal` object\n    defineProperty(dateTimeFormat, '__getInternalProperties', {\n        value: function () {\n            // NOTE: Non-standard, for internal use only\n            if (arguments[0] === secret)\n                return internal;\n        }\n    });\n\n    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n    internal['[[initializedIntlObject]]'] = true;\n\n    var\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n        requestedLocales = CanonicalizeLocaleList(locales),\n\n    // 4. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined below) with arguments options, \"any\", and \"date\".\n        options = ToDateTimeOptions(options, 'any', 'date'),\n\n    // 5. Let opt be a new Record.\n        opt = new Record();\n\n    // 6. Let matcher be the result of calling the GetOption abstract operation\n    //    (defined in 9.2.9) with arguments options, \"localeMatcher\", \"string\", a List\n    //    containing the two String values \"lookup\" and \"best fit\", and \"best fit\".\n        matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\n    // 7. Set opt.[[localeMatcher]] to matcher.\n    opt['[[localeMatcher]]'] = matcher;\n\n    var\n    // 8. Let DateTimeFormat be the standard built-in object that is the initial\n    //    value of Intl.DateTimeFormat.\n        DateTimeFormat = internals.DateTimeFormat, // This is what we *really* need\n\n    // 9. Let localeData be the value of the [[localeData]] internal property of\n    //    DateTimeFormat.\n        localeData = DateTimeFormat['[[localeData]]'],\n\n    // 10. Let r be the result of calling the ResolveLocale abstract operation\n    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n    //      DateTimeFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n    //      internal property of DateTimeFormat, and localeData.\n        r = ResolveLocale(DateTimeFormat['[[availableLocales]]'], requestedLocales,\n                opt, DateTimeFormat['[[relevantExtensionKeys]]'], localeData);\n\n    // 11. Set the [[locale]] internal property of dateTimeFormat to the value of\n    //     r.[[locale]].\n    internal['[[locale]]'] = r['[[locale]]'];\n\n    // 12. Set the [[calendar]] internal property of dateTimeFormat to the value of\n    //     r.[[ca]].\n    internal['[[calendar]]'] = r['[[ca]]'];\n\n    // 13. Set the [[numberingSystem]] internal property of dateTimeFormat to the value of\n    //     r.[[nu]].\n    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\n    // The specification doesn't tell us to do this, but it's helpful later on\n    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\n    var\n    // 14. Let dataLocale be the value of r.[[dataLocale]].\n        dataLocale = r['[[dataLocale]]'],\n\n    // 15. Let tz be the result of calling the [[Get]] internal method of options with\n    //     argument \"timeZone\".\n        tz = options.timeZone;\n\n    // 16. If tz is not undefined, then\n    if (tz !== undefined) {\n        // a. Let tz be ToString(tz).\n        // b. Convert tz to upper case as described in 6.1.\n        //    NOTE: If an implementation accepts additional time zone values, as permitted\n        //          under certain conditions by the Conformance clause, different casing\n        //          rules apply.\n        tz = toLatinUpperCase(tz);\n\n        // c. If tz is not \"UTC\", then throw a RangeError exception.\n        // ###TODO: accept more time zones###\n        if (tz !== 'UTC')\n            throw new RangeError('timeZone is not supported.');\n    }\n\n    // 17. Set the [[timeZone]] internal property of dateTimeFormat to tz.\n    internal['[[timeZone]]'] = tz;\n\n    // 18. Let opt be a new Record.\n    opt = new Record();\n\n    // 19. For each row of Table 3, except the header row, do:\n    for (var prop in dateTimeComponents) {\n        if (!hop.call(dateTimeComponents, prop))\n            continue;\n\n        var\n        // 20. Let prop be the name given in the Property column of the row.\n        // 21. Let value be the result of calling the GetOption abstract operation,\n        //     passing as argument options, the name given in the Property column of the\n        //     row, \"string\", a List containing the strings given in the Values column of\n        //     the row, and undefined.\n            value = GetOption(options, prop, 'string', dateTimeComponents[prop]);\n\n        // 22. Set opt.[[<prop>]] to value.\n        opt['[['+prop+']]'] = value;\n    }\n\n    var\n        // Assigned a value below\n        bestFormat,\n\n        // 23. Let dataLocaleData be the result of calling the [[Get]] internal method of\n        //     localeData with argument dataLocale.\n        dataLocaleData = localeData[dataLocale],\n\n        // 24. Let formats be the result of calling the [[Get]] internal method of\n        //     dataLocaleData with argument \"formats\".\n        //     Note: we process the CLDR formats into the spec'd structure\n        formats = ToDateTimeFormats(dataLocaleData.formats),\n\n        // 25. Let matcher be the result of calling the GetOption abstract operation with\n        //     arguments options, \"formatMatcher\", \"string\", a List containing the two String\n        //     values \"basic\" and \"best fit\", and \"best fit\".\n        matcher = GetOption(options, 'formatMatcher', 'string', new List('basic', 'best fit'), 'best fit');\n\n    // Optimization: caching the processed formats as a one time operation by\n    // replacing the initial structure from localeData\n    dataLocaleData.formats = formats;\n\n    // 26. If matcher is \"basic\", then\n    if (matcher === 'basic')\n        // 27. Let bestFormat be the result of calling the BasicFormatMatcher abstract\n        //     operation (defined below) with opt and formats.\n        bestFormat = BasicFormatMatcher(opt, formats);\n\n    // 28. Else\n    else\n        // 29. Let bestFormat be the result of calling the BestFitFormatMatcher\n        //     abstract operation (defined below) with opt and formats.\n        bestFormat = BestFitFormatMatcher(opt, formats);\n\n    // 30. For each row in Table 3, except the header row, do\n    for (var prop in dateTimeComponents) {\n        if (!hop.call(dateTimeComponents, prop))\n            continue;\n\n        // a. Let prop be the name given in the Property column of the row.\n        // b. Let pDesc be the result of calling the [[GetOwnProperty]] internal method of\n        //    bestFormat with argument prop.\n        // c. If pDesc is not undefined, then\n        if (hop.call(bestFormat, prop)) {\n            var\n            // i. Let p be the result of calling the [[Get]] internal method of bestFormat\n            //    with argument prop.\n                p = bestFormat[prop];\n\n            // ii. Set the [[<prop>]] internal property of dateTimeFormat to p.\n            internal['[['+prop+']]'] = p;\n        }\n    }\n\n    var\n        // Assigned a value below\n        pattern,\n\n    // 31. Let hr12 be the result of calling the GetOption abstract operation with\n    //     arguments options, \"hour12\", \"boolean\", undefined, and undefined.\n        hr12 = GetOption(options, 'hour12', 'boolean'/*, undefined, undefined*/);\n\n    // 32. If dateTimeFormat has an internal property [[hour]], then\n    if (internal['[[hour]]']) {\n        // a. If hr12 is undefined, then let hr12 be the result of calling the [[Get]]\n        //    internal method of dataLocaleData with argument \"hour12\".\n        hr12 = hr12 === undefined ? dataLocaleData.hour12 : hr12;\n\n        // b. Set the [[hour12]] internal property of dateTimeFormat to hr12.\n        internal['[[hour12]]'] = hr12;\n\n        // c. If hr12 is true, then\n        if (hr12 === true) {\n            var\n            // i. Let hourNo0 be the result of calling the [[Get]] internal method of\n            //    dataLocaleData with argument \"hourNo0\".\n                hourNo0 = dataLocaleData.hourNo0;\n\n            // ii. Set the [[hourNo0]] internal property of dateTimeFormat to hourNo0.\n            internal['[[hourNo0]]'] = hourNo0;\n\n            // iii. Let pattern be the result of calling the [[Get]] internal method of\n            //      bestFormat with argument \"pattern12\".\n            pattern = bestFormat.pattern12;\n        }\n\n        // d. Else\n        else\n            // i. Let pattern be the result of calling the [[Get]] internal method of\n            //    bestFormat with argument \"pattern\".\n            pattern = bestFormat.pattern;\n    }\n\n    // 33. Else\n    else\n        // a. Let pattern be the result of calling the [[Get]] internal method of\n        //    bestFormat with argument \"pattern\".\n        pattern = bestFormat.pattern;\n\n    // 34. Set the [[pattern]] internal property of dateTimeFormat to pattern.\n    internal['[[pattern]]'] = pattern;\n\n    // 35. Set the [[boundFormat]] internal property of dateTimeFormat to undefined.\n    internal['[[boundFormat]]'] = undefined;\n\n    // 36. Set the [[initializedDateTimeFormat]] internal property of dateTimeFormat to\n    //     true.\n    internal['[[initializedDateTimeFormat]]'] = true;\n\n    // In ES3, we need to pre-bind the format() function\n    if (es3)\n        dateTimeFormat.format = GetFormatDateTime.call(dateTimeFormat);\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // Return the newly initialised object\n    return dateTimeFormat;\n}\n\n/**\n * Several DateTimeFormat algorithms use values from the following table, which provides\n * property names and allowable values for the components of date and time formats:\n */\nvar dateTimeComponents = {\n         weekday: [ \"narrow\", \"short\", \"long\" ],\n             era: [ \"narrow\", \"short\", \"long\" ],\n            year: [ \"2-digit\", \"numeric\" ],\n           month: [ \"2-digit\", \"numeric\", \"narrow\", \"short\", \"long\" ],\n             day: [ \"2-digit\", \"numeric\" ],\n            hour: [ \"2-digit\", \"numeric\" ],\n          minute: [ \"2-digit\", \"numeric\" ],\n          second: [ \"2-digit\", \"numeric\" ],\n    timeZoneName: [ \"short\", \"long\" ]\n};\n\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\nfunction ToDateTimeFormats(formats) {\n    if (Object.prototype.toString.call(formats) === '[object Array]') {\n        return formats;\n    }\n    return src$cldr$$.createDateTimeFormats(formats);\n}\n\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\nfunction ToDateTimeOptions (options, required, defaults) {\n    // 1. If options is undefined, then let options be null, else let options be\n    //    ToObject(options).\n    if (options === undefined)\n        options = null;\n\n    else {\n        // (#12) options needs to be a Record, but it also needs to inherit properties\n        var opt2 = toObject(options);\n        options = new Record();\n\n        for (var k in opt2)\n            options[k] = opt2[k];\n    }\n\n    var\n    // 2. Let create be the standard built-in function object defined in ES5, 15.2.3.5.\n        create = objCreate,\n\n    // 3. Let options be the result of calling the [[Call]] internal method of create with\n    //    undefined as the this value and an argument list containing the single item\n    //    options.\n        options = create(options),\n\n    // 4. Let needDefaults be true.\n        needDefaults = true;\n\n    // 5. If required is \"date\" or \"any\", then\n    if (required === 'date' || required === 'any') {\n        // a. For each of the property names \"weekday\", \"year\", \"month\", \"day\":\n            // i. If the result of calling the [[Get]] internal method of options with the\n            //    property name is not undefined, then let needDefaults be false.\n        if (options.weekday !== undefined || options.year !== undefined\n                || options.month !== undefined || options.day !== undefined)\n            needDefaults = false;\n    }\n\n    // 6. If required is \"time\" or \"any\", then\n    if (required === 'time' || required === 'any') {\n        // a. For each of the property names \"hour\", \"minute\", \"second\":\n            // i. If the result of calling the [[Get]] internal method of options with the\n            //    property name is not undefined, then let needDefaults be false.\n        if (options.hour !== undefined || options.minute !== undefined || options.second !== undefined)\n                needDefaults = false;\n    }\n\n    // 7. If needDefaults is true and defaults is either \"date\" or \"all\", then\n    if (needDefaults && (defaults === 'date' || defaults === 'all'))\n        // a. For each of the property names \"year\", \"month\", \"day\":\n            // i. Call the [[DefineOwnProperty]] internal method of options with the\n            //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n            //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n        options.year = options.month = options.day = 'numeric';\n\n    // 8. If needDefaults is true and defaults is either \"time\" or \"all\", then\n    if (needDefaults && (defaults === 'time' || defaults === 'all'))\n        // a. For each of the property names \"hour\", \"minute\", \"second\":\n            // i. Call the [[DefineOwnProperty]] internal method of options with the\n            //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n            //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n        options.hour = options.minute = options.second = 'numeric';\n\n    // 9. Return options.\n    return options;\n}\n\n/**\n * When the BasicFormatMatcher abstract operation is called with two arguments options and\n * formats, the following steps are taken:\n */\nfunction BasicFormatMatcher (options, formats) {\n    return calculateScore(options, formats);\n}\n\n/**\n * Calculates score for BestFitFormatMatcher and BasicFormatMatcher.\n * Abstracted from BasicFormatMatcher section.\n */\nfunction calculateScore (options, formats, bestFit) {\n    var\n    // Additional penalty type when bestFit === true\n       diffDataTypePenalty = 8,\n\n    // 1. Let removalPenalty be 120.\n        removalPenalty = 120,\n\n    // 2. Let additionPenalty be 20.\n        additionPenalty = 20,\n\n    // 3. Let longLessPenalty be 8.\n        longLessPenalty = 8,\n\n    // 4. Let longMorePenalty be 6.\n        longMorePenalty = 6,\n\n    // 5. Let shortLessPenalty be 6.\n        shortLessPenalty = 6,\n\n    // 6. Let shortMorePenalty be 3.\n        shortMorePenalty = 3,\n\n    // 7. Let bestScore be -Infinity.\n        bestScore = -Infinity,\n\n    // 8. Let bestFormat be undefined.\n        bestFormat,\n\n    // 9. Let i be 0.\n        i = 0,\n\n    // 10. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n        len = formats.length;\n\n    // 11. Repeat while i < len:\n    while (i < len) {\n        var\n        // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n            format = formats[i],\n\n        // b. Let score be 0.\n            score = 0;\n\n        // c. For each property shown in Table 3:\n        for (var property in dateTimeComponents) {\n            if (!hop.call(dateTimeComponents, property))\n                continue;\n\n            var\n            // i. Let optionsProp be options.[[<property>]].\n                optionsProp = options['[['+ property +']]'],\n\n            // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n            //     with argument property.\n            // iii. If formatPropDesc is not undefined, then\n            //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n                formatProp = hop.call(format, property) ? format[property] : undefined;\n\n            // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n            //     additionPenalty.\n            if (optionsProp === undefined && formatProp !== undefined)\n                score -= additionPenalty;\n\n            // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n            //    removalPenalty.\n            else if (optionsProp !== undefined && formatProp === undefined)\n                score -= removalPenalty;\n\n            // vi. Else\n            else {\n                var\n                // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n                //    \"long\"].\n                    values = [ '2-digit', 'numeric', 'narrow', 'short', 'long' ],\n\n                // 2. Let optionsPropIndex be the index of optionsProp within values.\n                    optionsPropIndex = arrIndexOf.call(values, optionsProp),\n\n                // 3. Let formatPropIndex be the index of formatProp within values.\n                    formatPropIndex = arrIndexOf.call(values, formatProp),\n\n                // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n                    delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n\n                // When the bestFit argument is true, subtract additional penalty where data types are not the same\n                if (bestFit && (\n                    ((optionsProp === 'numeric' || optionsProp === '2-digit') && (formatProp !== 'numeric' && formatProp !== '2-digit') || (optionsProp !== 'numeric' && optionsProp !== '2-digit') && (formatProp === '2-digit' || formatProp === 'numeric'))\n                ))\n                    score -= diffDataTypePenalty;\n\n                // 5. If delta = 2, decrease score by longMorePenalty.\n                if (delta === 2)\n                    score -= longMorePenalty;\n\n                // 6. Else if delta = 1, decrease score by shortMorePenalty.\n                else if (delta === 1)\n                    score -= shortMorePenalty;\n\n                // 7. Else if delta = -1, decrease score by shortLessPenalty.\n                else if (delta === -1)\n                    score -= shortLessPenalty;\n\n                // 8. Else if delta = -2, decrease score by longLessPenalty.\n                else if (delta === -2)\n                    score -= longLessPenalty;\n            }\n        }\n\n        // d. If score > bestScore, then\n        if (score > bestScore) {\n            // i. Let bestScore be score.\n            bestScore = score;\n\n            // ii. Let bestFormat be format.\n            bestFormat = format;\n        }\n\n        // e. Increase i by 1.\n        i++;\n    }\n\n    // 12. Return bestFormat.\n    return bestFormat;\n}\n\n/**\n * When the BestFitFormatMatcher abstract operation is called with two arguments options\n * and formats, it performs implementation dependent steps, which should return a set of\n * component representations that a typical user of the selected locale would perceive as\n * at least as good as the one returned by BasicFormatMatcher.\n *\n * This polyfill defines the algorithm to be the same as BasicFormatMatcher,\n * with the addition of bonus points awarded where the requested format is of\n * the same data type as the potentially matching format.\n *\n * For example,\n *\n *     { month: 'numeric', day: 'numeric' }\n *\n * should match\n *\n *     { month: '2-digit', day: '2-digit' }\n *\n * rather than\n *\n *     { month: 'short', day: 'numeric' }\n *\n * This makes sense because a user requesting a formatted date with numeric parts would\n * not expect to see the returned format containing narrow, short or long part names\n */\nfunction BestFitFormatMatcher (options, formats) {\n    return calculateScore(options, formats, true);\n}\n\n/* 12.2.3 */internals.DateTimeFormat = {\n    '[[availableLocales]]': [],\n    '[[relevantExtensionKeys]]': ['ca', 'nu'],\n    '[[localeData]]': {}\n};\n\n/**\n * When the supportedLocalesOf method of Intl.DateTimeFormat is called, the\n * following steps are taken:\n */\n/* 12.2.2 */defineProperty(Intl.DateTimeFormat, 'supportedLocalesOf', {\n    configurable: true,\n    writable: true,\n    value: fnBind.call(supportedLocalesOf, internals.DateTimeFormat)\n});\n\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * DateTimeFormat object.\n */\n/* 12.3.2 */defineProperty(Intl.DateTimeFormat.prototype, 'format', {\n    configurable: true,\n    get: GetFormatDateTime\n});\n\nfunction GetFormatDateTime() {\n    var internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\n    // Satisfy test 12.3_b\n    if (!internal || !internal['[[initializedDateTimeFormat]]'])\n        throw new TypeError('`this` value for format() is not an initialized Intl.DateTimeFormat object.');\n\n    // The value of the [[Get]] attribute is a function that takes the following\n    // steps:\n\n    // 1. If the [[boundFormat]] internal property of this DateTimeFormat object\n    //    is undefined, then:\n    if (internal['[[boundFormat]]'] === undefined) {\n        var\n        // a. Let F be a Function object, with internal properties set as\n        //    specified for built-in functions in ES5, 15, or successor, and the\n        //    length property set to 0, that takes the argument date and\n        //    performs the following steps:\n            F = function () {\n                //   i. If date is not provided or is undefined, then let x be the\n                //      result as if by the expression Date.now() where Date.now is\n                //      the standard built-in function defined in ES5, 15.9.4.4.\n                //  ii. Else let x be ToNumber(date).\n                // iii. Return the result of calling the FormatDateTime abstract\n                //      operation (defined below) with arguments this and x.\n                var x = Number(arguments.length === 0 ? Date.now() : arguments[0]);\n                return FormatDateTime(this, x);\n            },\n        // b. Let bind be the standard built-in function object defined in ES5,\n        //    15.3.4.5.\n        // c. Let bf be the result of calling the [[Call]] internal method of\n        //    bind with F as the this value and an argument list containing\n        //    the single item this.\n            bf = fnBind.call(F, this);\n        // d. Set the [[boundFormat]] internal property of this NumberFormat\n        //    object to bf.\n        internal['[[boundFormat]]'] = bf;\n    }\n    // Return the value of the [[boundFormat]] internal property of this\n    // NumberFormat object.\n    return internal['[[boundFormat]]'];\n}\n\n/**\n * When the FormatDateTime abstract operation is called with arguments dateTimeFormat\n * (which must be an object initialized as a DateTimeFormat) and x (which must be a Number\n * value), it returns a String value representing x (interpreted as a time value as\n * specified in ES5, 15.9.1.1) according to the effective locale and the formatting\n * options of dateTimeFormat.\n */\nfunction FormatDateTime(dateTimeFormat, x) {\n    // 1. If x is not a finite Number, then throw a RangeError exception.\n    if (!isFinite(x))\n        throw new RangeError('Invalid valid date passed to format');\n\n    var\n        internal = dateTimeFormat.__getInternalProperties(secret),\n\n    // Creating restore point for properties on the RegExp object... please wait\n        regexpState = createRegExpRestore(),\n\n    // 2. Let locale be the value of the [[locale]] internal property of dateTimeFormat.\n        locale = internal['[[locale]]'],\n\n    // 3. Let nf be the result of creating a new NumberFormat object as if by the\n    // expression new Intl.NumberFormat([locale], {useGrouping: false}) where\n    // Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n        nf = new Intl.NumberFormat([locale], {useGrouping: false}),\n\n    // 4. Let nf2 be the result of creating a new NumberFormat object as if by the\n    // expression new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping:\n    // false}) where Intl.NumberFormat is the standard built-in constructor defined in\n    // 11.1.3.\n        nf2 = new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping: false}),\n\n    // 5. Let tm be the result of calling the ToLocalTime abstract operation (defined\n    // below) with x, the value of the [[calendar]] internal property of dateTimeFormat,\n    // and the value of the [[timeZone]] internal property of dateTimeFormat.\n        tm = ToLocalTime(x, internal['[[calendar]]'], internal['[[timeZone]]']),\n\n    // 6. Let result be the value of the [[pattern]] internal property of dateTimeFormat.\n        result = internal['[[pattern]]'],\n\n    // Need the locale minus any extensions\n        dataLocale = internal['[[dataLocale]]'],\n\n    // Need the calendar data from CLDR\n        localeData = internals.DateTimeFormat['[[localeData]]'][dataLocale].calendars,\n        ca = internal['[[calendar]]'];\n\n    // 7. For each row of Table 3, except the header row, do:\n    for (var p in dateTimeComponents) {\n        // a. If dateTimeFormat has an internal property with the name given in the\n        //    Property column of the row, then:\n        if (hop.call(internal, '[['+ p +']]')) {\n            var\n            // Assigned values below\n                pm, fv,\n\n            //   i. Let p be the name given in the Property column of the row.\n            //  ii. Let f be the value of the [[<p>]] internal property of dateTimeFormat.\n                f = internal['[['+ p +']]'],\n\n            // iii. Let v be the value of tm.[[<p>]].\n                v = tm['[['+ p +']]'];\n\n            //  iv. If p is \"year\" and v  0, then let v be 1 - v.\n            if (p === 'year' && v <= 0)\n                v = 1 - v;\n\n            //   v. If p is \"month\", then increase v by 1.\n            else if (p === 'month')\n                v++;\n\n            //  vi. If p is \"hour\" and the value of the [[hour12]] internal property of\n            //      dateTimeFormat is true, then\n            else if (p === 'hour' && internal['[[hour12]]'] === true) {\n                // 1. Let v be v modulo 12.\n                v = v % 12;\n\n                // 2. If v is equal to the value of tm.[[<p>]], then let pm be false; else\n                //    let pm be true.\n                pm = v !== tm['[['+ p +']]'];\n\n                // 3. If v is 0 and the value of the [[hourNo0]] internal property of\n                //    dateTimeFormat is true, then let v be 12.\n                if (v === 0 && internal['[[hourNo0]]'] === true)\n                    v = 12;\n            }\n\n            // vii. If f is \"numeric\", then\n            if (f === 'numeric')\n                // 1. Let fv be the result of calling the FormatNumber abstract operation\n                //    (defined in 11.3.2) with arguments nf and v.\n                fv = FormatNumber(nf, v);\n\n            // viii. Else if f is \"2-digit\", then\n            else if (f === '2-digit') {\n                // 1. Let fv be the result of calling the FormatNumber abstract operation\n                //    with arguments nf2 and v.\n                fv = FormatNumber(nf2, v);\n\n                // 2. If the length of fv is greater than 2, let fv be the substring of fv\n                //    containing the last two characters.\n                if (fv.length > 2)\n                    fv = fv.slice(-2);\n            }\n\n            // ix. Else if f is \"narrow\", \"short\", or \"long\", then let fv be a String\n            //     value representing f in the desired form; the String value depends upon\n            //     the implementation and the effective locale and calendar of\n            //     dateTimeFormat. If p is \"month\", then the String value may also depend\n            //     on whether dateTimeFormat has a [[day]] internal property. If p is\n            //     \"timeZoneName\", then the String value may also depend on the value of\n            //     the [[inDST]] field of tm.\n            else if (f in dateWidths) {\n                switch (p) {\n                    case 'month':\n                        fv = resolveDateString(localeData, ca, 'months', f, tm['[['+ p +']]']);\n                        break;\n\n                    case 'weekday':\n                        try {\n                            fv = resolveDateString(localeData, ca, 'days', f, tm['[['+ p +']]']);\n                            // fv = resolveDateString(ca.days, f)[tm['[['+ p +']]']];\n                        } catch (e) {\n                            throw new Error('Could not find weekday data for locale '+locale);\n                        }\n                        break;\n\n                    case 'timeZoneName':\n                        fv = ''; // TODO\n                        break;\n\n                    // TODO: Era\n                    default:\n                        fv = tm['[['+ p +']]'];\n                }\n            }\n\n            // x. Replace the substring of result that consists of \"{\", p, and \"}\", with\n            //    fv.\n            result = result.replace('{'+ p +'}', fv);\n        }\n    }\n    // 8. If dateTimeFormat has an internal property [[hour12]] whose value is true, then\n    if (internal['[[hour12]]'] === true) {\n        // a. If pm is true, then let fv be an implementation and locale dependent String\n        //    value representing post meridiem; else let fv be an implementation and\n        //    locale dependent String value representing ante meridiem.\n        fv = resolveDateString(localeData, ca, 'dayPeriods', pm ? 'pm' : 'am');\n\n        // b. Replace the substring of result that consists of \"{ampm}\", with fv.\n        result = result.replace('{ampm}', fv);\n    }\n\n    // Restore properties of the RegExp object\n    regexpState.exp.test(regexpState.input);\n\n    // 9. Return result.\n    return result;\n}\n\n/**\n * When the ToLocalTime abstract operation is called with arguments date, calendar, and\n * timeZone, the following steps are taken:\n */\nfunction ToLocalTime(date, calendar, timeZone) {\n    // 1. Apply calendrical calculations on date for the given calendar and time zone to\n    //    produce weekday, era, year, month, day, hour, minute, second, and inDST values.\n    //    The calculations should use best available information about the specified\n    //    calendar and time zone. If the calendar is \"gregory\", then the calculations must\n    //    match the algorithms specified in ES5, 15.9.1, except that calculations are not\n    //    bound by the restrictions on the use of best available information on time zones\n    //    for local time zone adjustment and daylight saving time adjustment imposed by\n    //    ES5, 15.9.1.7 and 15.9.1.8.\n    // ###TODO###\n    var d = new Date(date),\n        m = 'get' + (timeZone || '');\n\n    // 2. Return a Record with fields [[weekday]], [[era]], [[year]], [[month]], [[day]],\n    //    [[hour]], [[minute]], [[second]], and [[inDST]], each with the corresponding\n    //    calculated value.\n    return new Record({\n        '[[weekday]]': d[m + 'Day'](),\n        '[[era]]'    : +(d[m + 'FullYear']() >= 0),\n        '[[year]]'   : d[m + 'FullYear'](),\n        '[[month]]'  : d[m + 'Month'](),\n        '[[day]]'    : d[m + 'Date'](),\n        '[[hour]]'   : d[m + 'Hours'](),\n        '[[minute]]' : d[m + 'Minutes'](),\n        '[[second]]' : d[m + 'Seconds'](),\n        '[[inDST]]'  : false // ###TODO###\n    });\n}\n\n/**\n * The function returns a new object whose properties and attributes are set as if\n * constructed by an object literal assigning to each of the following properties the\n * value of the corresponding internal property of this DateTimeFormat object (see 12.4):\n * locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day,\n * hour, minute, second, and timeZoneName. Properties whose corresponding internal\n * properties are not present are not assigned.\n */\n/* 12.3.3 */defineProperty(Intl.DateTimeFormat.prototype, 'resolvedOptions', {\n    writable: true,\n    configurable: true,\n    value: function () {\n        var prop,\n            descs = new Record(),\n            props = [\n                'locale', 'calendar', 'numberingSystem', 'timeZone', 'hour12', 'weekday',\n                'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName'\n            ],\n            internal = this != null && typeof this === 'object' && getInternalProperties(this);\n\n        // Satisfy test 12.3_b\n        if (!internal || !internal['[[initializedDateTimeFormat]]'])\n            throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.DateTimeFormat object.');\n\n        for (var i = 0, max = props.length; i < max; i++) {\n            if (hop.call(internal, prop = '[[' + props[i] + ']]'))\n                descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n        }\n\n        return objCreate({}, descs);\n    }\n});\n\n// Sect 13 Locale Sensitive Functions of the ECMAScript Language Specification\n// ===========================================================================\n\nvar ls = Intl.__localeSensitiveProtos = {\n    Number: {},\n    Date:   {}\n};\n\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n/* 13.2.1 */ls.Number.toLocaleString = function () {\n    // Satisfy test 13.2.1_1\n    if (Object.prototype.toString.call(this) !== '[object Number]')\n        throw new TypeError('`this` value must be a number for Number.prototype.toLocaleString()');\n\n    // 1. Let x be this Number value (as defined in ES5, 15.7.4).\n    // 2. If locales is not provided, then let locales be undefined.\n    // 3. If options is not provided, then let options be undefined.\n    // 4. Let numberFormat be the result of creating a new object as if by the\n    //    expression new Intl.NumberFormat(locales, options) where\n    //    Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n    // 5. Return the result of calling the FormatNumber abstract operation\n    //    (defined in 11.3.2) with arguments numberFormat and x.\n    return FormatNumber(new NumberFormatConstructor(arguments[0], arguments[1]), this);\n};\n\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n/* 13.3.1 */ls.Date.toLocaleString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]')\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleString()');\n\n    var\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n        x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x))\n        return 'Invalid Date';\n\n    var\n    // 3. If locales is not provided, then let locales be undefined.\n        locales = arguments[0],\n\n    // 4. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"any\", and \"all\".\n        options = ToDateTimeOptions(options, 'any', 'all'),\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n        dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\n/**\n * When the toLocaleDateString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n/* 13.3.2 */ls.Date.toLocaleDateString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]')\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleDateString()');\n\n    var\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n        x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x))\n        return 'Invalid Date';\n\n    var\n    // 3. If locales is not provided, then let locales be undefined.\n        locales = arguments[0],\n\n    // 4. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"date\", and \"date\".\n        options = ToDateTimeOptions(options, 'date', 'date'),\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n        dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\n/**\n * When the toLocaleTimeString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n/* 13.3.3 */ls.Date.toLocaleTimeString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]')\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleTimeString()');\n\n    var\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n        x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x))\n        return 'Invalid Date';\n\n    var\n    // 3. If locales is not provided, then let locales be undefined.\n        locales = arguments[0],\n\n    // 4. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"time\", and \"time\".\n        options = ToDateTimeOptions(options, 'time', 'time'),\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n        dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\ndefineProperty(Intl, '__applyLocaleSensitivePrototypes', {\n    writable: true,\n    configurable: true,\n    value: function () {\n        defineProperty(Number.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Number.toLocaleString });\n        // Need this here for IE 8, to avoid the _DontEnum_ bug\n        defineProperty(Date.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Date.toLocaleString });\n\n        for (var k in ls.Date) {\n            if (hop.call(ls.Date, k))\n                defineProperty(Date.prototype, k, { writable: true, configurable: true, value: ls.Date[k] });\n        }\n    }\n});\n\n/**\n * Can't really ship a single script with data for hundreds of locales, so we provide\n * this __addLocaleData method as a means for the developer to add the data on an\n * as-needed basis\n */\ndefineProperty(Intl, '__addLocaleData', {\n    value: function (data) {\n        if (!IsStructurallyValidLanguageTag(data.locale))\n            throw new Error(\"Object passed doesn't identify itself with a valid language tag\");\n\n        addLocaleData(data, data.locale);\n    }\n});\n\nfunction addLocaleData (data, tag) {\n    // Both NumberFormat and DateTimeFormat require number data, so throw if it isn't present\n    if (!data.number)\n        throw new Error(\"Object passed doesn't contain locale data for Intl.NumberFormat\");\n\n    var locale,\n        locales = [ tag ],\n        parts   = tag.split('-');\n\n    // Create fallbacks for locale data with scripts, e.g. Latn, Hans, Vaii, etc\n    if (parts.length > 2 && parts[1].length === 4)\n        arrPush.call(locales, parts[0] + '-' + parts[2]);\n\n    while (locale = arrShift.call(locales)) {\n        // Add to NumberFormat internal properties as per 11.2.3\n        arrPush.call(internals.NumberFormat['[[availableLocales]]'], locale);\n        internals.NumberFormat['[[localeData]]'][locale] = data.number;\n\n        // ...and DateTimeFormat internal properties as per 12.2.3\n        if (data.date) {\n            data.date.nu = data.number.nu;\n            arrPush.call(internals.DateTimeFormat['[[availableLocales]]'], locale);\n            internals.DateTimeFormat['[[localeData]]'][locale] = data.date;\n        }\n    }\n\n    // If this is the first set of locale data added, make it the default\n    if (defaultLocale === undefined)\n        defaultLocale = tag;\n\n    // 11.3 (the NumberFormat prototype object is an Intl.NumberFormat instance)\n    if (!numberFormatProtoInitialised) {\n        InitializeNumberFormat(Intl.NumberFormat.prototype);\n        numberFormatProtoInitialised = true;\n    }\n\n    // 11.3 (the NumberFormat prototype object is an Intl.NumberFormat instance)\n    if (data.date && !dateTimeFormatProtoInitialised) {\n        InitializeDateTimeFormat(Intl.DateTimeFormat.prototype);\n        dateTimeFormatProtoInitialised = true;\n    }\n}\n\n// Helper functions\n// ================\n\n/**\n * A function to deal with the inaccuracy of calculating log10 in pre-ES6\n * JavaScript environments. Math.log(num) / Math.LN10 was responsible for\n * causing issue #62.\n */\nfunction log10Floor (n) {\n    // ES6 provides the more accurate Math.log10\n    if (typeof Math.log10 === 'function')\n        return Math.floor(Math.log10(n));\n\n    var x = Math.round(Math.log(n) * Math.LOG10E);\n    return x - (Number('1e' + x) > n);\n}\n\n/**\n * A merge of the Intl.{Constructor}.supportedLocalesOf functions\n * To make life easier, the function should be bound to the constructor's internal\n * properties object.\n */\nfunction supportedLocalesOf(locales) {\n    /*jshint validthis:true */\n\n    // Bound functions only have the `this` value altered if being used as a constructor,\n    // this lets us imitate a native function that has no constructor\n    if (!hop.call(this, '[[availableLocales]]'))\n        throw new TypeError('supportedLocalesOf() is not a constructor');\n\n    var\n    // Create an object whose props can be used to restore the values of RegExp props\n        regexpState = createRegExpRestore(),\n\n    // 1. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n    // 2. Let availableLocales be the value of the [[availableLocales]] internal\n    //    property of the standard built-in object that is the initial value of\n    //    Intl.NumberFormat.\n\n        availableLocales = this['[[availableLocales]]'],\n\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n        requestedLocales = CanonicalizeLocaleList(locales);\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // 4. Return the result of calling the SupportedLocales abstract operation\n    //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n    //    and options.\n    return SupportedLocales(availableLocales, requestedLocales, options);\n}\n\n/**\n * Returns a string for a date component, resolved using multiple inheritance as specified\n * as specified in the Unicode Technical Standard 35.\n */\nfunction resolveDateString(data, ca, component, width, key) {\n    // From http://www.unicode.org/reports/tr35/tr35.html#Multiple_Inheritance:\n    // 'In clearly specified instances, resources may inherit from within the same locale.\n    //  For example, ... the Buddhist calendar inherits from the Gregorian calendar.'\n    var obj = data[ca] && data[ca][component]\n                ? data[ca][component]\n                : data.gregory[component],\n\n        // \"sideways\" inheritance resolves strings when a key doesn't exist\n        alts = {\n            narrow: ['short', 'long'],\n            short:  ['long', 'narrow'],\n            long:   ['short', 'narrow']\n        },\n\n        //\n        resolved = hop.call(obj, width)\n                  ? obj[width]\n                  : hop.call(obj, alts[width][0])\n                      ? obj[alts[width][0]]\n                      : obj[alts[width][1]];\n\n    // `key` wouldn't be specified for components 'dayPeriods'\n    return key != null ? resolved[key] : resolved;\n}\n\n/**\n * A map that doesn't contain Object in its prototype chain\n */\nRecord.prototype = objCreate(null);\nfunction Record (obj) {\n    // Copy only own properties over unless this object is already a Record instance\n    for (var k in obj) {\n        if (obj instanceof Record || hop.call(obj, k))\n            defineProperty(this, k, { value: obj[k], enumerable: true, writable: true, configurable: true });\n    }\n}\n\n/**\n * An ordered list\n */\nList.prototype = objCreate(null);\nfunction List() {\n    defineProperty(this, 'length', { writable:true, value: 0 });\n\n    if (arguments.length)\n        arrPush.apply(this, arrSlice.call(arguments));\n}\n\n/**\n * Constructs a regular expression to restore tainted RegExp properties\n */\nfunction createRegExpRestore () {\n    var esc = /[.?*+^$[\\]\\\\(){}|-]/g,\n        lm  = RegExp.lastMatch || '',\n        ml  = RegExp.multiline ? 'm' : '',\n        ret = { input: RegExp.input },\n        reg = new List(),\n        has = false,\n        cap = {};\n\n    // Create a snapshot of all the 'captured' properties\n    for (var i = 1; i <= 9; i++)\n        has = (cap['$'+i] = RegExp['$'+i]) || has;\n\n    // Now we've snapshotted some properties, escape the lastMatch string\n    lm = lm.replace(esc, '\\\\$&');\n\n    // If any of the captured strings were non-empty, iterate over them all\n    if (has) {\n        for (var i = 1; i <= 9; i++) {\n            var m = cap['$'+i];\n\n            // If it's empty, add an empty capturing group\n            if (!m)\n                lm = '()' + lm;\n\n            // Else find the string in lm and escape & wrap it to capture it\n            else {\n                m = m.replace(esc, '\\\\$&');\n                lm = lm.replace(m, '(' + m + ')');\n            }\n\n            // Push it to the reg and chop lm to make sure further groups come after\n            arrPush.call(reg, lm.slice(0, lm.indexOf('(') + 1));\n            lm = lm.slice(lm.indexOf('(') + 1);\n        }\n    }\n\n    // Create the regular expression that will reconstruct the RegExp properties\n    ret.exp = new RegExp(arrJoin.call(reg, '') + lm, ml);\n\n    return ret;\n}\n\n/**\n * Convert only a-z to uppercase as per section 6.1 of the spec\n */\nfunction toLatinUpperCase (str) {\n    var i = str.length;\n\n    while (i--) {\n        var ch = str.charAt(i);\n\n        if (ch >= \"a\" && ch <= \"z\")\n            str = str.slice(0, i) + ch.toUpperCase() + str.slice(i+1);\n    }\n\n    return str;\n}\n\n/**\n * Mimics ES5's abstract ToObject() function\n */\nfunction toObject (arg) {\n    if (arg == null)\n        throw new TypeError('Cannot convert null or undefined to object');\n\n    return Object(arg);\n}\n\n/**\n * Returns \"internal\" properties for an object\n */\nfunction getInternalProperties (obj) {\n    if (hop.call(obj, '__getInternalProperties'))\n        return obj.__getInternalProperties(secret);\n    else\n        return objCreate(null);\n}\n\nexports[\"default\"] = Intl;\n\n//# sourceMappingURL=core.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/intl/lib/core.js\n ** module id = 222\n ** module chunks = 1\n **/","/* jshint esnext: true, laxbreak:true */\n\n/**\n* Defines regular expressions for various operations related to the BCP 47 syntax,\n* as defined at http://tools.ietf.org/html/bcp47#section-2.1\n*/\n\n\"use strict\";\n\nvar\n    // extlang       = 3ALPHA              ; selected ISO 639 codes\n    //                 *2(\"-\" 3ALPHA)      ; permanently reserved\n    extlang = '[a-z]{3}(?:-[a-z]{3}){0,2}',\n\n    // language      = 2*3ALPHA            ; shortest ISO 639 code\n    //                 [\"-\" extlang]       ; sometimes followed by\n    //                                     ; extended language subtags\n    //               / 4ALPHA              ; or reserved for future use\n    //               / 5*8ALPHA            ; or registered language subtag\n    language = '(?:[a-z]{2,3}(?:-' + extlang + ')?|[a-z]{4}|[a-z]{5,8})',\n\n    // script        = 4ALPHA              ; ISO 15924 code\n    script = '[a-z]{4}',\n\n    // region        = 2ALPHA              ; ISO 3166-1 code\n    //               / 3DIGIT              ; UN M.49 code\n    region = '(?:[a-z]{2}|\\\\d{3})',\n\n    // variant       = 5*8alphanum         ; registered variants\n    //               / (DIGIT 3alphanum)\n    variant = '(?:[a-z0-9]{5,8}|\\\\d[a-z0-9]{3})',\n\n    //                                     ; Single alphanumerics\n    //                                     ; \"x\" reserved for private use\n    // singleton     = DIGIT               ; 0 - 9\n    //               / %x41-57             ; A - W\n    //               / %x59-5A             ; Y - Z\n    //               / %x61-77             ; a - w\n    //               / %x79-7A             ; y - z\n    singleton = '[0-9a-wy-z]',\n\n    // extension     = singleton 1*(\"-\" (2*8alphanum))\n    extension = singleton + '(?:-[a-z0-9]{2,8})+',\n\n    // privateuse    = \"x\" 1*(\"-\" (1*8alphanum))\n    privateuse = 'x(?:-[a-z0-9]{1,8})+',\n\n    // irregular     = \"en-GB-oed\"         ; irregular tags do not match\n    //               / \"i-ami\"             ; the 'langtag' production and\n    //               / \"i-bnn\"             ; would not otherwise be\n    //               / \"i-default\"         ; considered 'well-formed'\n    //               / \"i-enochian\"        ; These tags are all valid,\n    //               / \"i-hak\"             ; but most are deprecated\n    //               / \"i-klingon\"         ; in favor of more modern\n    //               / \"i-lux\"             ; subtags or subtag\n    //               / \"i-mingo\"           ; combination\n    //               / \"i-navajo\"\n    //               / \"i-pwn\"\n    //               / \"i-tao\"\n    //               / \"i-tay\"\n    //               / \"i-tsu\"\n    //               / \"sgn-BE-FR\"\n    //               / \"sgn-BE-NL\"\n    //               / \"sgn-CH-DE\"\n    irregular = '(?:en-GB-oed'\n              + '|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)'\n              + '|sgn-(?:BE-FR|BE-NL|CH-DE))',\n\n    // regular       = \"art-lojban\"        ; these tags match the 'langtag'\n    //               / \"cel-gaulish\"       ; production, but their subtags\n    //               / \"no-bok\"            ; are not extended language\n    //               / \"no-nyn\"            ; or variant subtags: their meaning\n    //               / \"zh-guoyu\"          ; is defined by their registration\n    //               / \"zh-hakka\"          ; and all of these are deprecated\n    //               / \"zh-min\"            ; in favor of a more modern\n    //               / \"zh-min-nan\"        ; subtag or sequence of subtags\n    //               / \"zh-xiang\"\n    regular = '(?:art-lojban|cel-gaulish|no-bok|no-nyn'\n            + '|zh-(?:guoyu|hakka|min|min-nan|xiang))',\n\n    // grandfathered = irregular           ; non-redundant tags registered\n    //               / regular             ; during the RFC 3066 era\n    grandfathered = '(?:' + irregular + '|' + regular + ')',\n\n    // langtag       = language\n    //                 [\"-\" script]\n    //                 [\"-\" region]\n    //                 *(\"-\" variant)\n    //                 *(\"-\" extension)\n    //                 [\"-\" privateuse]\n    langtag = language + '(?:-' + script + ')?(?:-' + region + ')?(?:-'\n            + variant + ')*(?:-' + extension + ')*(?:-' + privateuse + ')?';\n\nvar expBCP47Syntax = RegExp('^(?:'+langtag+'|'+privateuse+'|'+grandfathered+')$', 'i');\n\nvar expVariantDupes = RegExp('^(?!x).*?-('+variant+')-(?:\\\\w{4,8}-(?!x-))*\\\\1\\\\b', 'i');\n\nvar expSingletonDupes = RegExp('^(?!x).*?-('+singleton+')-(?:\\\\w+-(?!x-))*\\\\1\\\\b', 'i');\n\nvar expExtSequences = RegExp('-'+extension, 'ig');\nexports.expBCP47Syntax = expBCP47Syntax, exports.expVariantDupes = expVariantDupes, exports.expSingletonDupes = expSingletonDupes, exports.expExtSequences = expExtSequences;\n\n//# sourceMappingURL=exp.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/intl/lib/exp.js\n ** module id = 223\n ** module chunks = 1\n **/"],"sourceRoot":""}